// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package tari_generated

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// WalletClient is the client API for Wallet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WalletClient interface {
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error)
	// Returns the current operational state of the wallet.
	//
	// This RPC provides an overview of the wallet's internal status, including:
	// - The latest blockchain height scanned by the wallet
	// - The current balance (available, pending incoming/outgoing)
	// - Network connectivity status with the base node
	//
	// This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
	// synchronized, and connected to the Tari network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.getState({});
	// console.log(response.scanned_height); // e.g., 1523493
	// console.log(response.balance.available_balance); // e.g., 1234567890
	// console.log(response.network.status); // e.g., "Online"
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "scanned_height": 1523493,
	//	  "balance": {
	//	    "available_balance": 1234567890,
	//	    "pending_incoming_balance": 100000000,
	//	    "pending_outgoing_balance": 0
	//	  },
	//	  "network": {
	//	    "status": "Online",
	//	    "avg_latency_ms": 28,
	//	    "num_node_connections": 8
	//	  }
	//	}
	//
	// ```
	GetState(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateResponse, error)
	// This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.checkConnectivity({});
	// console.log(response.status); // e.g., 1 (Online)
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "status": "Online"
	//	}
	//
	// ```
	CheckConnectivity(ctx context.Context, in *GetConnectivityRequest, opts ...grpc.CallOption) (*CheckConnectivityResponse, error)
	// Check for new updates
	CheckForUpdates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SoftwareUpdate, error)
	// The `Identify` RPC call returns the identity information of the wallet node.
	// This includes:
	// - **Public Key**: The wallet's cryptographic public key.
	// - **Public Address**: The wallet's public address used to receive funds.
	// - **Node ID**: The unique identifier of the wallet node in the network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// // Call the Identify RPC method
	//
	//	client.Identify({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Identity Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	  "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
	//	  "public_address": "14HVCEeZC2RGE4SDn3yGwqzXepJ2LDqXva7kb4fherYMQR9dF7341T3TjMZobB1a6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	  "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
	//	}
	//
	// ```
	Identify(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error)
	// This RPC returns two types of wallet addresses: interactive and one-sided addresses.
	// It provides these addresses in byte format as part of the response.
	// - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
	// - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
	//
	// Example usage (JavaScript):
	// // Call the GetAddress RPC method
	//
	//	client.GetAddress({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	//	// ```json
	//
	//	{
	//	  "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
	//	  "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
	//	}
	//
	// ```
	GetAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAddressResponse, error)
	// This RPC returns addresses generated for a specific payment ID. It provides both the interactive
	// and one-sided addresses for the given payment ID, along with their respective representations in
	// base58 and emoji formats.
	//
	// Example usage (JavaScript):
	//
	// ```javascript
	// // Prepare the payment ID for the request
	// const paymentId = Buffer.from('your_payment_id_here', 'hex');
	// const request = { payment_id: paymentId };
	//
	// // Call the GetPaymentIdAddress RPC method
	//
	//	client.GetPaymentIdAddress(request, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Payment ID Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
	//	 "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
	//	}
	//
	// ```
	GetPaymentIdAddress(ctx context.Context, in *GetPaymentIdAddressRequest, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error)
	// This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
	// The response includes:
	// - Raw binary
	// - Base58-encoded (human-readable)
	// - Emoji-encoded (for fun and friendliness)
	//
	// Example usage (JavaScript with gRPC):
	//
	// ```js
	// const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
	//
	//	client.getCompleteAddress({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// Sample response:
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
	//	 "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
	//	}
	//
	// ```
	GetCompleteAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error)
	// This call supports standard interactive transactions (Mimblewimble),
	// one-sided transactions, and one-sided-to-stealth-address transactions.
	// Each recipient must include a valid Tari address, amount, fee, and payment type.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const recipient = new PaymentRecipient();
	// recipient.setAddress("14HVCEeZ...");
	// recipient.setAmount(1000000); // 1 T
	// recipient.setFeePerGram(25);
	// recipient.setPaymentType(PaymentType.ONE_SIDED);
	// recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
	//
	// const request = new TransferRequest();
	// request.setRecipientsList([recipient]);
	//
	//	client.transfer(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.toObject());
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "results": [
	//	    {
	//	      "address": "14HVCEeZ...",
	//	      "transaction_id": 12345,
	//	      "is_success": true,
	//	      "failure_message": ""
	//	    }
	//	  ]
	//	}
	Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error)
	// Returns the transaction details for the given transaction IDs.
	//
	// The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
	// The response includes details such as transaction status, direction, amount, fee, and more.
	//
	// ### Request Parameters:
	//
	// - `transaction_ids` (required):
	//   - **Type**: `repeated uint64`
	//   - **Description**: A list of transaction IDs to query.
	//   - **Restrictions**:
	//   - Must contain at least one ID.
	//   - All IDs must be valid unsigned 64-bit integers.
	//   - Duplicates will be ignored; only the first occurrence is processed.
	//   - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { transaction_ids: [12345, 67890] };
	//
	//	client.getTransactionInfo(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.transactions);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_OUTBOUND",
	//	      "amount": 1000000,
	//	      "fee": 25,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	GetTransactionInfo(ctx context.Context, in *GetTransactionInfoRequest, opts ...grpc.CallOption) (*GetTransactionInfoResponse, error)
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-001"
	//	  }
	//	};
	//
	// const call = client.getCompletedTransactions(request);
	//
	//	call.on('data', (response) => {
	//	  console.log(response.transaction);
	//	});
	//
	// call.on('error', console.error);
	// call.on('end', () => console.log("Stream ended"));
	// ```
	//
	// ### Sample Streamed JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 12345,
	//	    "source_address": "0x1234abcd...",
	//	    "dest_address": "0x5678efgh...",
	//	    "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	    "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	    "amount": 500000,
	//	    "fee": 20,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0xabcdef...",
	//	    "timestamp": 1681234567,
	//	    "payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 1523493
	//	  }
	//	}
	//
	// ```
	GetCompletedTransactions(ctx context.Context, in *GetCompletedTransactionsRequest, opts ...grpc.CallOption) (Wallet_GetCompletedTransactionsClient, error)
	// Returns all transactions that were mined at a specific block height.
	//
	// The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
	// at the specified block height. The response includes all transactions in a single response,
	// with each transaction including details such as status, direction, amount,
	// fees, and associated metadata.
	//
	// ### Request Parameters:
	//
	// - `block_height` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The specific block height to fetch transactions for.
	//   - **Restrictions**:
	//   - Must be a valid block height (greater than 0).
	//   - If the block height is beyond the current chain height, no transactions will be returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  block_height: 1523493
	//	};
	//
	// const response = await client.getBlockHeightTransactions(request);
	// console.log(response.transactions);
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	      "amount": 500000,
	//	      "fee": 20,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	//
	// ```
	GetBlockHeightTransactions(ctx context.Context, in *GetBlockHeightTransactionsRequest, opts ...grpc.CallOption) (*GetBlockHeightTransactionsResponse, error)
	// Returns the wallet balance details.
	//
	// The `GetBalance` call retrieves the current balance status of the wallet,
	// optionally filtered by a specific `payment_id`. The response includes detailed
	// breakdowns of available, pending incoming/outgoing, and timelocked balances.
	//
	// ### Request Parameters:
	//
	// - `payment_id` (optional):
	//   - **Type**: `UserPaymentId` (one of several formats).
	//   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
	//   - **Accepted Formats** (must provide **only one**):
	//   - `u256`: a 32-byte hexadecimal identifier.
	//   - `utf8_string`: a human-readable string ID.
	//   - `user_bytes`: raw binary bytes.
	//   - **Restrictions**:
	//   - Only one format must be provided at a time.
	//   - If multiple or no formats are provided within `payment_id`, the request will return an error.
	//   - If `payment_id` is omitted, the total wallet balance is returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-002"
	//	  }
	//	};
	//
	//	client.getBalance(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Balance:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "available_balance": 950000,
	//	  "pending_incoming_balance": 200000,
	//	  "pending_outgoing_balance": 50000,
	//	  "timelocked_balance": 100000
	//	}
	//
	// ```
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	// Returns the total value of unspent outputs in the wallet.
	//
	// The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
	// currently held by the wallet. These are outputs that have not yet been spent or time-locked,
	// and are available for future transactions.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getUnspentAmounts({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Total unspent amount:", response.amount);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "amount": 1250000
	//	}
	//
	// ```
	GetUnspentAmounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetUnspentAmountsResponse, error)
	// Creates a transaction that splits funds into multiple smaller outputs.
	//
	// The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
	// This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
	// The resulting transaction is broadcast and can be tracked via its transaction ID.
	//
	// ### Request Parameters:
	//
	// - `amount_per_split` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The value of each individual output in the split.
	//   - **Restrictions**: Must be greater than zero.
	//
	// - `split_count` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The number of outputs to create.
	//   - **Restrictions**: Must be greater than zero and within practical system limits.
	//
	// - `fee_per_gram` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The transaction fee rate (per gram of weight).
	//   - **Restrictions**: Should be set high enough to ensure confirmation.
	//
	// - `lock_height` (optional):
	//   - **Type**: `uint64`
	//   - **Description**: The earliest block height at which the transaction becomes valid.
	//   - **Restrictions**: Defaults to 0 if not specified.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: A user-defined identifier for tracking or referencing the transaction.
	//   - **Restrictions**: Optional; can be left empty.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  amount_per_split: 100000,
	//	  split_count: 5,
	//	  fee_per_gram: 25,
	//	  lock_height: 0,
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.coinSplit(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Created CoinSplit Tx ID:", response.tx_id);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_id": 987654321
	//	}
	//
	// ```
	CoinSplit(ctx context.Context, in *CoinSplitRequest, opts ...grpc.CallOption) (*CoinSplitResponse, error)
	// Imports UTXOs into the wallet as spendable outputs.
	//
	// The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
	// into the wallet, marking them as spendable without needing rewindable metadata.
	// Each UTXO is associated with a transaction ID in the response.
	//
	// ### Request Parameters:
	//
	// - `outputs` (required):
	//   - **Type**: `repeated UnblindedOutput`
	//   - **Description**: A list of unblinded outputs to import into the wallet.
	//   - **Restrictions**:
	//   - Each output must be valid and convertible to an internal UTXO format.
	//   - The list must contain at least one item.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: An optional user-defined identifier to associate with the imported outputs.
	//   - **Restrictions**:
	//   - Can be left empty if not needed.
	//   - Must be a valid byte string if provided.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  outputs: [/* array of unblinded outputs */],
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.importUtxos(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Imported Tx IDs:", response.tx_ids);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_ids": [101, 102, 103]
	//	}
	//
	// ```
	ImportUtxos(ctx context.Context, in *ImportUtxosRequest, opts ...grpc.CallOption) (*ImportUtxosResponse, error)
	// Returns the wallet's current network connectivity status.
	//
	// The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
	// including whether it is online, the number of active peer connections, and the average latency
	// to the configured base node.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getNetworkStatus({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Network Status:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "status": "ONLINE",
	//	  "avg_latency_ms": 142,
	//	  "num_node_connections": 8
	//	}
	//
	// ```
	//
	// ### Status Field Values:
	//
	// The `status` field indicates the current network connectivity of the wallet. Possible values are:
	//
	// - `ONLINE`:
	//   - The wallet is fully connected to the network and functioning normally.
	//   - The node has enough active peer connections to operate efficiently.
	//
	// - `DEGRADED`:
	//   - The wallet is connected to some peers but not enough to maintain full functionality.
	//   - This could indicate issues with network connectivity, such as intermittent disconnections or insufficient peers, leading to reduced performance or reliability.
	//
	// - `OFFLINE`:
	//   - The wallet is not connected to any peers.
	//   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
	GetNetworkStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NetworkStatusResponse, error)
	// Returns a list of peers currently connected to the wallet.
	//
	// The `ListConnectedPeers` call retrieves information about peers that the wallet is currently
	// connected to. This includes details such as peer addresses, connection status, supported protocols,
	// and other metadata relevant to the connection.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Response Fields:
	//
	// - **connected_peers**: List of peers currently connected to the wallet.
	//   - **public_key**: The peer's public key (bytes).
	//   - **node_id**: The unique node ID of the peer (bytes).
	//   - **addresses**: List of the peer's addresses (repeated Address).
	//   - **last_connection**: The timestamp of the last connection attempt (uint64).
	//   - **flags**: Flags associated with the peer (uint32).
	//   - **banned_until**: The timestamp until which the peer is banned (uint64, 0 if not banned).
	//   - **banned_reason**: The reason for banning the peer (string, empty if not banned).
	//   - **offline_at**: The timestamp indicating when the peer went offline (uint64, 0 if online).
	//   - **features**: The features supported by the peer (uint32).
	//   - **supported_protocols**: List of supported protocols by the peer (repeated bytes).
	//   - **user_agent**: The user agent advertised by the peer (string).
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.listConnectedPeers({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Connected Peers:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "connected_peers": [
	//	    {
	//	      "public_key": "0x1234abcd...",
	//	      "node_id": "0x5678efgh...",
	//	      "addresses": [
	//	        "127.0.0.1:18080",
	//	        "192.168.1.2:18080"
	//	      ],
	//	      "last_connection": 1625493123,
	//	      "flags": 1,
	//	      "banned_until": 0,
	//	      "banned_reason": "",
	//	      "offline_at": 0,
	//	      "features": 10,
	//	      "supported_protocols": [
	//	        "protocol_v1",
	//	        "protocol_v2"
	//	      ],
	//	      "user_agent": "TariBaseNode/1.0.0"
	//	    }
	//	  ]
	//	}
	//
	// ```
	ListConnectedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListConnectedPeersResponse, error)
	// Cancels a specific transaction by its ID.
	//
	// The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
	// If the cancellation is successful, the response will indicate success. Otherwise, the response will
	// contain a failure message with the reason for the failure.
	//
	// ### Request Parameters:
	//
	// - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
	//
	// ### Response Fields:
	//
	// - **is_success**: A boolean indicating whether the cancellation was successful (bool).
	//   - `true` if the cancellation was successful, `false` if not.
	//
	// - **failure_message**: A string that provides the reason for the failure, if applicable (string).
	//   - This field will be empty if the cancellation was successful.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { tx_id: 12345 };
	//
	//	client.cancelTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	//
	// ```
	CancelTransaction(ctx context.Context, in *CancelTransactionRequest, opts ...grpc.CallOption) (*CancelTransactionResponse, error)
	// Will trigger a complete revalidation of all wallet outputs.
	RevalidateAllTransactions(ctx context.Context, in *RevalidateRequest, opts ...grpc.CallOption) (*RevalidateResponse, error)
	// Will trigger a validation of all wallet outputs.
	ValidateAllTransactions(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
	// Sends a XTR SHA Atomic Swap transaction.
	//
	// The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
	// transaction using SHA. It allows the sender to send a payment to the recipient
	// in exchange for an atomic swap, with SHA used as the secret for the swap.
	// The method accepts the recipient's information and initiates the transaction.
	//
	// ### Request Parameters:
	//   - **recipient** (required): A PaymentRecipient object containing the recipient's address,
	//     the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the transaction.
	// - **pre_image**: The SHA pre-image of the atomic swap.
	// - **output_hash**: The hash of the output associated with the transaction.
	// - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
	// - **failure_message**: Provides an error message if the transaction failed.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  recipient: {
	//	    address: "t1abc12345",
	//	    amount: 1000000,
	//	    fee_per_gram: 10,
	//	    payment_id: "0xdeadbeef"
	//	  }
	//	};
	//
	//	client.sendShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "pre_image": "0xabcdef1234567890",
	//	  "output_hash": "0x123456abcdef7890",
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	SendShaAtomicSwapTransaction(ctx context.Context, in *SendShaAtomicSwapRequest, opts ...grpc.CallOption) (*SendShaAtomicSwapResponse, error)
	// Creates a burn transaction for burning a specified amount of Tari currency.
	//
	// The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
	// by initiating a burn transaction. It allows the user to specify the amount to burn,
	// along with a fee per gram and optionally a payment ID and claim public key.
	//
	// ### Request Parameters:
	// - **amount** (required): The amount of Tari to be burned.
	// - **fee_per_gram** (required): The fee per gram for the transaction.
	// - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
	// - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the burn transaction.
	// - **is_success**: Indicates whether the burn transaction was successfully created.
	// - **failure_message**: Provides an error message if the transaction creation failed.
	// - **commitment**: The commitment associated with the burn transaction.
	// - **ownership_proof**: A proof of ownership for the burned coins.
	// - **range_proof**: The range proof associated with the burned coins.
	// - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  amount: 1000000,
	//	  fee_per_gram: 10,
	//	  claim_public_key: "0xabcdef1234567890",
	//	  payment_id: "0xdeadbeef"
	//	};
	//
	//	client.createBurnTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "is_success": true,
	//	  "failure_message": "",
	//	  "commitment": "0xcommitmenthash",
	//	  "ownership_proof": "0xownershipproof",
	//	  "range_proof": "0xrangeproof",
	//	  "reciprocal_claim_public_key": "0xreciprocalpublickey"
	//	}
	CreateBurnTransaction(ctx context.Context, in *CreateBurnTransactionRequest, opts ...grpc.CallOption) (*CreateBurnTransactionResponse, error)
	// Claims a SHA Atomic Swap transaction using a pre-image and output hash.
	//
	// The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
	// a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
	// previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
	// secret required to spend the output.
	//
	// ### Request Parameters:
	// - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
	// - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
	// - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
	//
	// ### Input Validation:
	// - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
	// - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
	// - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
	//	  pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
	//	  fee_per_gram: 10
	//	};
	//
	//	client.claimShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 789654,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimShaAtomicSwapTransaction(ctx context.Context, in *ClaimShaAtomicSwapRequest, opts ...grpc.CallOption) (*ClaimShaAtomicSwapResponse, error)
	// Claims an HTLC refund transaction after the timelock period has passed.
	//
	// The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
	// to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
	// This is possible only after the output's timelock has expired.
	//
	// ### Request Parameters:
	// - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
	// - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
	//
	// ### Input Validation:
	// - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
	// - `fee_per_gram` must be a non-zero `uint64` value.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output_hash: "aabbccddeeff0011...99",
	//	  fee_per_gram: 20
	//	};
	//
	//	client.claimHtlcRefundTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 889977,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimHtlcRefundTransaction(ctx context.Context, in *ClaimHtlcRefundRequest, opts ...grpc.CallOption) (*ClaimHtlcRefundResponse, error)
	// Creates a transaction with a template registration output
	CreateTemplateRegistration(ctx context.Context, in *CreateTemplateRegistrationRequest, opts ...grpc.CallOption) (*CreateTemplateRegistrationResponse, error)
	// The SetBaseNode call configures the base node peer for the wallet.
	//
	// This RPC sets the public key and network address of the base node peer that the wallet should communicate with.
	//
	// ### Request Fields:
	// - `public_key_hex` (string): The public key of the base node, provided as a hex string.
	// - `net_address` (string): The multiaddress of the base node (e.g., `/ip4/127.0.0.1/tcp/18141`).
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  public_key_hex: "0281bdfc...",
	//	  net_address: "/ip4/127.0.0.1/tcp/18141"
	//	};
	//
	//	client.setBaseNode(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Base node set successfully");
	//	});
	//
	// ```
	//
	// ### Sample JSON Request:
	// ```json
	//
	//	{
	//	  "public_key_hex": "0281bdfc...",
	//	  "net_address": "/ip4/127.0.0.1/tcp/18141"
	//	}
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	// {}
	// ```
	SetBaseNode(ctx context.Context, in *SetBaseNodeRequest, opts ...grpc.CallOption) (*SetBaseNodeResponse, error)
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	// const call = client.streamTransactionEvents({});
	//
	//	call.on("data", (response) => {
	//	  console.log("Transaction Event:", response.transaction);
	//	});
	//
	//	call.on("end", () => {
	//	  console.log("Stream ended.");
	//	});
	//
	//	call.on("error", (err) => {
	//	  console.error("Stream error:", err);
	//	});
	//
	// ```
	//
	// ### Sample JSON Streamed Response:
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "event": "Mined",
	//	    "tx_id": "103248",
	//	    "source_address": "0xabc123...",
	//	    "dest_address": "0xdef456...",
	//	    "status": "Completed",
	//	    "direction": "Outbound",
	//	    "amount": 100000000,
	//	    "payment_id": "0xdeadbeef..."
	//	  }
	//	}
	//
	// ```
	StreamTransactionEvents(ctx context.Context, in *TransactionEventRequest, opts ...grpc.CallOption) (Wallet_StreamTransactionEventsClient, error)
	RegisterValidatorNode(ctx context.Context, in *RegisterValidatorNodeRequest, opts ...grpc.CallOption) (*RegisterValidatorNodeResponse, error)
	ImportTransactions(ctx context.Context, in *ImportTransactionsRequest, opts ...grpc.CallOption) (*ImportTransactionsResponse, error)
}

type walletClient struct {
	cc grpc.ClientConnInterface
}

func NewWalletClient(cc grpc.ClientConnInterface) WalletClient {
	return &walletClient{cc}
}

func (c *walletClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error) {
	out := new(GetVersionResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetState(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateResponse, error) {
	out := new(GetStateResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CheckConnectivity(ctx context.Context, in *GetConnectivityRequest, opts ...grpc.CallOption) (*CheckConnectivityResponse, error) {
	out := new(CheckConnectivityResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/CheckConnectivity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CheckForUpdates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SoftwareUpdate, error) {
	out := new(SoftwareUpdate)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/CheckForUpdates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) Identify(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error) {
	out := new(GetIdentityResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/Identify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAddressResponse, error) {
	out := new(GetAddressResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetPaymentIdAddress(ctx context.Context, in *GetPaymentIdAddressRequest, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error) {
	out := new(GetCompleteAddressResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetPaymentIdAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetCompleteAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error) {
	out := new(GetCompleteAddressResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetCompleteAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error) {
	out := new(TransferResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/Transfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetTransactionInfo(ctx context.Context, in *GetTransactionInfoRequest, opts ...grpc.CallOption) (*GetTransactionInfoResponse, error) {
	out := new(GetTransactionInfoResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetTransactionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetCompletedTransactions(ctx context.Context, in *GetCompletedTransactionsRequest, opts ...grpc.CallOption) (Wallet_GetCompletedTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Wallet_serviceDesc.Streams[0], "/tari.rpc.Wallet/GetCompletedTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &walletGetCompletedTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Wallet_GetCompletedTransactionsClient interface {
	Recv() (*GetCompletedTransactionsResponse, error)
	grpc.ClientStream
}

type walletGetCompletedTransactionsClient struct {
	grpc.ClientStream
}

func (x *walletGetCompletedTransactionsClient) Recv() (*GetCompletedTransactionsResponse, error) {
	m := new(GetCompletedTransactionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *walletClient) GetBlockHeightTransactions(ctx context.Context, in *GetBlockHeightTransactionsRequest, opts ...grpc.CallOption) (*GetBlockHeightTransactionsResponse, error) {
	out := new(GetBlockHeightTransactionsResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetBlockHeightTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetUnspentAmounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetUnspentAmountsResponse, error) {
	out := new(GetUnspentAmountsResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetUnspentAmounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CoinSplit(ctx context.Context, in *CoinSplitRequest, opts ...grpc.CallOption) (*CoinSplitResponse, error) {
	out := new(CoinSplitResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/CoinSplit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ImportUtxos(ctx context.Context, in *ImportUtxosRequest, opts ...grpc.CallOption) (*ImportUtxosResponse, error) {
	out := new(ImportUtxosResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/ImportUtxos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetNetworkStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NetworkStatusResponse, error) {
	out := new(NetworkStatusResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/GetNetworkStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ListConnectedPeers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ListConnectedPeersResponse, error) {
	out := new(ListConnectedPeersResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/ListConnectedPeers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CancelTransaction(ctx context.Context, in *CancelTransactionRequest, opts ...grpc.CallOption) (*CancelTransactionResponse, error) {
	out := new(CancelTransactionResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/CancelTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) RevalidateAllTransactions(ctx context.Context, in *RevalidateRequest, opts ...grpc.CallOption) (*RevalidateResponse, error) {
	out := new(RevalidateResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/RevalidateAllTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ValidateAllTransactions(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) {
	out := new(ValidateResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/ValidateAllTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) SendShaAtomicSwapTransaction(ctx context.Context, in *SendShaAtomicSwapRequest, opts ...grpc.CallOption) (*SendShaAtomicSwapResponse, error) {
	out := new(SendShaAtomicSwapResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/SendShaAtomicSwapTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CreateBurnTransaction(ctx context.Context, in *CreateBurnTransactionRequest, opts ...grpc.CallOption) (*CreateBurnTransactionResponse, error) {
	out := new(CreateBurnTransactionResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/CreateBurnTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ClaimShaAtomicSwapTransaction(ctx context.Context, in *ClaimShaAtomicSwapRequest, opts ...grpc.CallOption) (*ClaimShaAtomicSwapResponse, error) {
	out := new(ClaimShaAtomicSwapResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ClaimHtlcRefundTransaction(ctx context.Context, in *ClaimHtlcRefundRequest, opts ...grpc.CallOption) (*ClaimHtlcRefundResponse, error) {
	out := new(ClaimHtlcRefundResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/ClaimHtlcRefundTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CreateTemplateRegistration(ctx context.Context, in *CreateTemplateRegistrationRequest, opts ...grpc.CallOption) (*CreateTemplateRegistrationResponse, error) {
	out := new(CreateTemplateRegistrationResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/CreateTemplateRegistration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) SetBaseNode(ctx context.Context, in *SetBaseNodeRequest, opts ...grpc.CallOption) (*SetBaseNodeResponse, error) {
	out := new(SetBaseNodeResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/SetBaseNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) StreamTransactionEvents(ctx context.Context, in *TransactionEventRequest, opts ...grpc.CallOption) (Wallet_StreamTransactionEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Wallet_serviceDesc.Streams[1], "/tari.rpc.Wallet/StreamTransactionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &walletStreamTransactionEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Wallet_StreamTransactionEventsClient interface {
	Recv() (*TransactionEventResponse, error)
	grpc.ClientStream
}

type walletStreamTransactionEventsClient struct {
	grpc.ClientStream
}

func (x *walletStreamTransactionEventsClient) Recv() (*TransactionEventResponse, error) {
	m := new(TransactionEventResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *walletClient) RegisterValidatorNode(ctx context.Context, in *RegisterValidatorNodeRequest, opts ...grpc.CallOption) (*RegisterValidatorNodeResponse, error) {
	out := new(RegisterValidatorNodeResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/RegisterValidatorNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ImportTransactions(ctx context.Context, in *ImportTransactionsRequest, opts ...grpc.CallOption) (*ImportTransactionsResponse, error) {
	out := new(ImportTransactionsResponse)
	err := c.cc.Invoke(ctx, "/tari.rpc.Wallet/ImportTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletServer is the server API for Wallet service.
// All implementations must embed UnimplementedWalletServer
// for forward compatibility
type WalletServer interface {
	GetVersion(context.Context, *GetVersionRequest) (*GetVersionResponse, error)
	// Returns the current operational state of the wallet.
	//
	// This RPC provides an overview of the wallet's internal status, including:
	// - The latest blockchain height scanned by the wallet
	// - The current balance (available, pending incoming/outgoing)
	// - Network connectivity status with the base node
	//
	// This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
	// synchronized, and connected to the Tari network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.getState({});
	// console.log(response.scanned_height); // e.g., 1523493
	// console.log(response.balance.available_balance); // e.g., 1234567890
	// console.log(response.network.status); // e.g., "Online"
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "scanned_height": 1523493,
	//	  "balance": {
	//	    "available_balance": 1234567890,
	//	    "pending_incoming_balance": 100000000,
	//	    "pending_outgoing_balance": 0
	//	  },
	//	  "network": {
	//	    "status": "Online",
	//	    "avg_latency_ms": 28,
	//	    "num_node_connections": 8
	//	  }
	//	}
	//
	// ```
	GetState(context.Context, *GetStateRequest) (*GetStateResponse, error)
	// This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.checkConnectivity({});
	// console.log(response.status); // e.g., 1 (Online)
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "status": "Online"
	//	}
	//
	// ```
	CheckConnectivity(context.Context, *GetConnectivityRequest) (*CheckConnectivityResponse, error)
	// Check for new updates
	CheckForUpdates(context.Context, *Empty) (*SoftwareUpdate, error)
	// The `Identify` RPC call returns the identity information of the wallet node.
	// This includes:
	// - **Public Key**: The wallet's cryptographic public key.
	// - **Public Address**: The wallet's public address used to receive funds.
	// - **Node ID**: The unique identifier of the wallet node in the network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// // Call the Identify RPC method
	//
	//	client.Identify({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Identity Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	  "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
	//	  "public_address": "14HVCEeZC2RGE4SDn3yGwqzXepJ2LDqXva7kb4fherYMQR9dF7341T3TjMZobB1a6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	  "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
	//	}
	//
	// ```
	Identify(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error)
	// This RPC returns two types of wallet addresses: interactive and one-sided addresses.
	// It provides these addresses in byte format as part of the response.
	// - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
	// - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
	//
	// Example usage (JavaScript):
	// // Call the GetAddress RPC method
	//
	//	client.GetAddress({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	//	// ```json
	//
	//	{
	//	  "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
	//	  "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
	//	}
	//
	// ```
	GetAddress(context.Context, *Empty) (*GetAddressResponse, error)
	// This RPC returns addresses generated for a specific payment ID. It provides both the interactive
	// and one-sided addresses for the given payment ID, along with their respective representations in
	// base58 and emoji formats.
	//
	// Example usage (JavaScript):
	//
	// ```javascript
	// // Prepare the payment ID for the request
	// const paymentId = Buffer.from('your_payment_id_here', 'hex');
	// const request = { payment_id: paymentId };
	//
	// // Call the GetPaymentIdAddress RPC method
	//
	//	client.GetPaymentIdAddress(request, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Payment ID Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
	//	 "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
	//	}
	//
	// ```
	GetPaymentIdAddress(context.Context, *GetPaymentIdAddressRequest) (*GetCompleteAddressResponse, error)
	// This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
	// The response includes:
	// - Raw binary
	// - Base58-encoded (human-readable)
	// - Emoji-encoded (for fun and friendliness)
	//
	// Example usage (JavaScript with gRPC):
	//
	// ```js
	// const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
	//
	//	client.getCompleteAddress({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// Sample response:
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
	//	 "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
	//	}
	//
	// ```
	GetCompleteAddress(context.Context, *Empty) (*GetCompleteAddressResponse, error)
	// This call supports standard interactive transactions (Mimblewimble),
	// one-sided transactions, and one-sided-to-stealth-address transactions.
	// Each recipient must include a valid Tari address, amount, fee, and payment type.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const recipient = new PaymentRecipient();
	// recipient.setAddress("14HVCEeZ...");
	// recipient.setAmount(1000000); // 1 T
	// recipient.setFeePerGram(25);
	// recipient.setPaymentType(PaymentType.ONE_SIDED);
	// recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
	//
	// const request = new TransferRequest();
	// request.setRecipientsList([recipient]);
	//
	//	client.transfer(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.toObject());
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "results": [
	//	    {
	//	      "address": "14HVCEeZ...",
	//	      "transaction_id": 12345,
	//	      "is_success": true,
	//	      "failure_message": ""
	//	    }
	//	  ]
	//	}
	Transfer(context.Context, *TransferRequest) (*TransferResponse, error)
	// Returns the transaction details for the given transaction IDs.
	//
	// The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
	// The response includes details such as transaction status, direction, amount, fee, and more.
	//
	// ### Request Parameters:
	//
	// - `transaction_ids` (required):
	//   - **Type**: `repeated uint64`
	//   - **Description**: A list of transaction IDs to query.
	//   - **Restrictions**:
	//   - Must contain at least one ID.
	//   - All IDs must be valid unsigned 64-bit integers.
	//   - Duplicates will be ignored; only the first occurrence is processed.
	//   - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { transaction_ids: [12345, 67890] };
	//
	//	client.getTransactionInfo(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.transactions);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_OUTBOUND",
	//	      "amount": 1000000,
	//	      "fee": 25,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	GetTransactionInfo(context.Context, *GetTransactionInfoRequest) (*GetTransactionInfoResponse, error)
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-001"
	//	  }
	//	};
	//
	// const call = client.getCompletedTransactions(request);
	//
	//	call.on('data', (response) => {
	//	  console.log(response.transaction);
	//	});
	//
	// call.on('error', console.error);
	// call.on('end', () => console.log("Stream ended"));
	// ```
	//
	// ### Sample Streamed JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 12345,
	//	    "source_address": "0x1234abcd...",
	//	    "dest_address": "0x5678efgh...",
	//	    "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	    "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	    "amount": 500000,
	//	    "fee": 20,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0xabcdef...",
	//	    "timestamp": 1681234567,
	//	    "payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 1523493
	//	  }
	//	}
	//
	// ```
	GetCompletedTransactions(*GetCompletedTransactionsRequest, Wallet_GetCompletedTransactionsServer) error
	// Returns all transactions that were mined at a specific block height.
	//
	// The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
	// at the specified block height. The response includes all transactions in a single response,
	// with each transaction including details such as status, direction, amount,
	// fees, and associated metadata.
	//
	// ### Request Parameters:
	//
	// - `block_height` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The specific block height to fetch transactions for.
	//   - **Restrictions**:
	//   - Must be a valid block height (greater than 0).
	//   - If the block height is beyond the current chain height, no transactions will be returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  block_height: 1523493
	//	};
	//
	// const response = await client.getBlockHeightTransactions(request);
	// console.log(response.transactions);
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	      "amount": 500000,
	//	      "fee": 20,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	//
	// ```
	GetBlockHeightTransactions(context.Context, *GetBlockHeightTransactionsRequest) (*GetBlockHeightTransactionsResponse, error)
	// Returns the wallet balance details.
	//
	// The `GetBalance` call retrieves the current balance status of the wallet,
	// optionally filtered by a specific `payment_id`. The response includes detailed
	// breakdowns of available, pending incoming/outgoing, and timelocked balances.
	//
	// ### Request Parameters:
	//
	// - `payment_id` (optional):
	//   - **Type**: `UserPaymentId` (one of several formats).
	//   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
	//   - **Accepted Formats** (must provide **only one**):
	//   - `u256`: a 32-byte hexadecimal identifier.
	//   - `utf8_string`: a human-readable string ID.
	//   - `user_bytes`: raw binary bytes.
	//   - **Restrictions**:
	//   - Only one format must be provided at a time.
	//   - If multiple or no formats are provided within `payment_id`, the request will return an error.
	//   - If `payment_id` is omitted, the total wallet balance is returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-002"
	//	  }
	//	};
	//
	//	client.getBalance(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Balance:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "available_balance": 950000,
	//	  "pending_incoming_balance": 200000,
	//	  "pending_outgoing_balance": 50000,
	//	  "timelocked_balance": 100000
	//	}
	//
	// ```
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	// Returns the total value of unspent outputs in the wallet.
	//
	// The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
	// currently held by the wallet. These are outputs that have not yet been spent or time-locked,
	// and are available for future transactions.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getUnspentAmounts({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Total unspent amount:", response.amount);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "amount": 1250000
	//	}
	//
	// ```
	GetUnspentAmounts(context.Context, *Empty) (*GetUnspentAmountsResponse, error)
	// Creates a transaction that splits funds into multiple smaller outputs.
	//
	// The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
	// This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
	// The resulting transaction is broadcast and can be tracked via its transaction ID.
	//
	// ### Request Parameters:
	//
	// - `amount_per_split` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The value of each individual output in the split.
	//   - **Restrictions**: Must be greater than zero.
	//
	// - `split_count` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The number of outputs to create.
	//   - **Restrictions**: Must be greater than zero and within practical system limits.
	//
	// - `fee_per_gram` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The transaction fee rate (per gram of weight).
	//   - **Restrictions**: Should be set high enough to ensure confirmation.
	//
	// - `lock_height` (optional):
	//   - **Type**: `uint64`
	//   - **Description**: The earliest block height at which the transaction becomes valid.
	//   - **Restrictions**: Defaults to 0 if not specified.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: A user-defined identifier for tracking or referencing the transaction.
	//   - **Restrictions**: Optional; can be left empty.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  amount_per_split: 100000,
	//	  split_count: 5,
	//	  fee_per_gram: 25,
	//	  lock_height: 0,
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.coinSplit(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Created CoinSplit Tx ID:", response.tx_id);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_id": 987654321
	//	}
	//
	// ```
	CoinSplit(context.Context, *CoinSplitRequest) (*CoinSplitResponse, error)
	// Imports UTXOs into the wallet as spendable outputs.
	//
	// The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
	// into the wallet, marking them as spendable without needing rewindable metadata.
	// Each UTXO is associated with a transaction ID in the response.
	//
	// ### Request Parameters:
	//
	// - `outputs` (required):
	//   - **Type**: `repeated UnblindedOutput`
	//   - **Description**: A list of unblinded outputs to import into the wallet.
	//   - **Restrictions**:
	//   - Each output must be valid and convertible to an internal UTXO format.
	//   - The list must contain at least one item.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: An optional user-defined identifier to associate with the imported outputs.
	//   - **Restrictions**:
	//   - Can be left empty if not needed.
	//   - Must be a valid byte string if provided.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  outputs: [/* array of unblinded outputs */],
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.importUtxos(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Imported Tx IDs:", response.tx_ids);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_ids": [101, 102, 103]
	//	}
	//
	// ```
	ImportUtxos(context.Context, *ImportUtxosRequest) (*ImportUtxosResponse, error)
	// Returns the wallet's current network connectivity status.
	//
	// The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
	// including whether it is online, the number of active peer connections, and the average latency
	// to the configured base node.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getNetworkStatus({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Network Status:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "status": "ONLINE",
	//	  "avg_latency_ms": 142,
	//	  "num_node_connections": 8
	//	}
	//
	// ```
	//
	// ### Status Field Values:
	//
	// The `status` field indicates the current network connectivity of the wallet. Possible values are:
	//
	// - `ONLINE`:
	//   - The wallet is fully connected to the network and functioning normally.
	//   - The node has enough active peer connections to operate efficiently.
	//
	// - `DEGRADED`:
	//   - The wallet is connected to some peers but not enough to maintain full functionality.
	//   - This could indicate issues with network connectivity, such as intermittent disconnections or insufficient peers, leading to reduced performance or reliability.
	//
	// - `OFFLINE`:
	//   - The wallet is not connected to any peers.
	//   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
	GetNetworkStatus(context.Context, *Empty) (*NetworkStatusResponse, error)
	// Returns a list of peers currently connected to the wallet.
	//
	// The `ListConnectedPeers` call retrieves information about peers that the wallet is currently
	// connected to. This includes details such as peer addresses, connection status, supported protocols,
	// and other metadata relevant to the connection.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Response Fields:
	//
	// - **connected_peers**: List of peers currently connected to the wallet.
	//   - **public_key**: The peer's public key (bytes).
	//   - **node_id**: The unique node ID of the peer (bytes).
	//   - **addresses**: List of the peer's addresses (repeated Address).
	//   - **last_connection**: The timestamp of the last connection attempt (uint64).
	//   - **flags**: Flags associated with the peer (uint32).
	//   - **banned_until**: The timestamp until which the peer is banned (uint64, 0 if not banned).
	//   - **banned_reason**: The reason for banning the peer (string, empty if not banned).
	//   - **offline_at**: The timestamp indicating when the peer went offline (uint64, 0 if online).
	//   - **features**: The features supported by the peer (uint32).
	//   - **supported_protocols**: List of supported protocols by the peer (repeated bytes).
	//   - **user_agent**: The user agent advertised by the peer (string).
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.listConnectedPeers({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Connected Peers:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "connected_peers": [
	//	    {
	//	      "public_key": "0x1234abcd...",
	//	      "node_id": "0x5678efgh...",
	//	      "addresses": [
	//	        "127.0.0.1:18080",
	//	        "192.168.1.2:18080"
	//	      ],
	//	      "last_connection": 1625493123,
	//	      "flags": 1,
	//	      "banned_until": 0,
	//	      "banned_reason": "",
	//	      "offline_at": 0,
	//	      "features": 10,
	//	      "supported_protocols": [
	//	        "protocol_v1",
	//	        "protocol_v2"
	//	      ],
	//	      "user_agent": "TariBaseNode/1.0.0"
	//	    }
	//	  ]
	//	}
	//
	// ```
	ListConnectedPeers(context.Context, *Empty) (*ListConnectedPeersResponse, error)
	// Cancels a specific transaction by its ID.
	//
	// The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
	// If the cancellation is successful, the response will indicate success. Otherwise, the response will
	// contain a failure message with the reason for the failure.
	//
	// ### Request Parameters:
	//
	// - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
	//
	// ### Response Fields:
	//
	// - **is_success**: A boolean indicating whether the cancellation was successful (bool).
	//   - `true` if the cancellation was successful, `false` if not.
	//
	// - **failure_message**: A string that provides the reason for the failure, if applicable (string).
	//   - This field will be empty if the cancellation was successful.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { tx_id: 12345 };
	//
	//	client.cancelTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	//
	// ```
	CancelTransaction(context.Context, *CancelTransactionRequest) (*CancelTransactionResponse, error)
	// Will trigger a complete revalidation of all wallet outputs.
	RevalidateAllTransactions(context.Context, *RevalidateRequest) (*RevalidateResponse, error)
	// Will trigger a validation of all wallet outputs.
	ValidateAllTransactions(context.Context, *ValidateRequest) (*ValidateResponse, error)
	// Sends a XTR SHA Atomic Swap transaction.
	//
	// The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
	// transaction using SHA. It allows the sender to send a payment to the recipient
	// in exchange for an atomic swap, with SHA used as the secret for the swap.
	// The method accepts the recipient's information and initiates the transaction.
	//
	// ### Request Parameters:
	//   - **recipient** (required): A PaymentRecipient object containing the recipient's address,
	//     the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the transaction.
	// - **pre_image**: The SHA pre-image of the atomic swap.
	// - **output_hash**: The hash of the output associated with the transaction.
	// - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
	// - **failure_message**: Provides an error message if the transaction failed.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  recipient: {
	//	    address: "t1abc12345",
	//	    amount: 1000000,
	//	    fee_per_gram: 10,
	//	    payment_id: "0xdeadbeef"
	//	  }
	//	};
	//
	//	client.sendShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "pre_image": "0xabcdef1234567890",
	//	  "output_hash": "0x123456abcdef7890",
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	SendShaAtomicSwapTransaction(context.Context, *SendShaAtomicSwapRequest) (*SendShaAtomicSwapResponse, error)
	// Creates a burn transaction for burning a specified amount of Tari currency.
	//
	// The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
	// by initiating a burn transaction. It allows the user to specify the amount to burn,
	// along with a fee per gram and optionally a payment ID and claim public key.
	//
	// ### Request Parameters:
	// - **amount** (required): The amount of Tari to be burned.
	// - **fee_per_gram** (required): The fee per gram for the transaction.
	// - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
	// - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the burn transaction.
	// - **is_success**: Indicates whether the burn transaction was successfully created.
	// - **failure_message**: Provides an error message if the transaction creation failed.
	// - **commitment**: The commitment associated with the burn transaction.
	// - **ownership_proof**: A proof of ownership for the burned coins.
	// - **range_proof**: The range proof associated with the burned coins.
	// - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  amount: 1000000,
	//	  fee_per_gram: 10,
	//	  claim_public_key: "0xabcdef1234567890",
	//	  payment_id: "0xdeadbeef"
	//	};
	//
	//	client.createBurnTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "is_success": true,
	//	  "failure_message": "",
	//	  "commitment": "0xcommitmenthash",
	//	  "ownership_proof": "0xownershipproof",
	//	  "range_proof": "0xrangeproof",
	//	  "reciprocal_claim_public_key": "0xreciprocalpublickey"
	//	}
	CreateBurnTransaction(context.Context, *CreateBurnTransactionRequest) (*CreateBurnTransactionResponse, error)
	// Claims a SHA Atomic Swap transaction using a pre-image and output hash.
	//
	// The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
	// a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
	// previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
	// secret required to spend the output.
	//
	// ### Request Parameters:
	// - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
	// - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
	// - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
	//
	// ### Input Validation:
	// - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
	// - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
	// - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
	//	  pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
	//	  fee_per_gram: 10
	//	};
	//
	//	client.claimShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 789654,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimShaAtomicSwapTransaction(context.Context, *ClaimShaAtomicSwapRequest) (*ClaimShaAtomicSwapResponse, error)
	// Claims an HTLC refund transaction after the timelock period has passed.
	//
	// The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
	// to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
	// This is possible only after the output's timelock has expired.
	//
	// ### Request Parameters:
	// - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
	// - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
	//
	// ### Input Validation:
	// - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
	// - `fee_per_gram` must be a non-zero `uint64` value.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output_hash: "aabbccddeeff0011...99",
	//	  fee_per_gram: 20
	//	};
	//
	//	client.claimHtlcRefundTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 889977,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimHtlcRefundTransaction(context.Context, *ClaimHtlcRefundRequest) (*ClaimHtlcRefundResponse, error)
	// Creates a transaction with a template registration output
	CreateTemplateRegistration(context.Context, *CreateTemplateRegistrationRequest) (*CreateTemplateRegistrationResponse, error)
	// The SetBaseNode call configures the base node peer for the wallet.
	//
	// This RPC sets the public key and network address of the base node peer that the wallet should communicate with.
	//
	// ### Request Fields:
	// - `public_key_hex` (string): The public key of the base node, provided as a hex string.
	// - `net_address` (string): The multiaddress of the base node (e.g., `/ip4/127.0.0.1/tcp/18141`).
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  public_key_hex: "0281bdfc...",
	//	  net_address: "/ip4/127.0.0.1/tcp/18141"
	//	};
	//
	//	client.setBaseNode(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Base node set successfully");
	//	});
	//
	// ```
	//
	// ### Sample JSON Request:
	// ```json
	//
	//	{
	//	  "public_key_hex": "0281bdfc...",
	//	  "net_address": "/ip4/127.0.0.1/tcp/18141"
	//	}
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	// {}
	// ```
	SetBaseNode(context.Context, *SetBaseNodeRequest) (*SetBaseNodeResponse, error)
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	// const call = client.streamTransactionEvents({});
	//
	//	call.on("data", (response) => {
	//	  console.log("Transaction Event:", response.transaction);
	//	});
	//
	//	call.on("end", () => {
	//	  console.log("Stream ended.");
	//	});
	//
	//	call.on("error", (err) => {
	//	  console.error("Stream error:", err);
	//	});
	//
	// ```
	//
	// ### Sample JSON Streamed Response:
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "event": "Mined",
	//	    "tx_id": "103248",
	//	    "source_address": "0xabc123...",
	//	    "dest_address": "0xdef456...",
	//	    "status": "Completed",
	//	    "direction": "Outbound",
	//	    "amount": 100000000,
	//	    "payment_id": "0xdeadbeef..."
	//	  }
	//	}
	//
	// ```
	StreamTransactionEvents(*TransactionEventRequest, Wallet_StreamTransactionEventsServer) error
	RegisterValidatorNode(context.Context, *RegisterValidatorNodeRequest) (*RegisterValidatorNodeResponse, error)
	ImportTransactions(context.Context, *ImportTransactionsRequest) (*ImportTransactionsResponse, error)
	mustEmbedUnimplementedWalletServer()
}

// UnimplementedWalletServer must be embedded to have forward compatible implementations.
type UnimplementedWalletServer struct {
}

func (UnimplementedWalletServer) GetVersion(context.Context, *GetVersionRequest) (*GetVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedWalletServer) GetState(context.Context, *GetStateRequest) (*GetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetState not implemented")
}
func (UnimplementedWalletServer) CheckConnectivity(context.Context, *GetConnectivityRequest) (*CheckConnectivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckConnectivity not implemented")
}
func (UnimplementedWalletServer) CheckForUpdates(context.Context, *Empty) (*SoftwareUpdate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckForUpdates not implemented")
}
func (UnimplementedWalletServer) Identify(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Identify not implemented")
}
func (UnimplementedWalletServer) GetAddress(context.Context, *Empty) (*GetAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddress not implemented")
}
func (UnimplementedWalletServer) GetPaymentIdAddress(context.Context, *GetPaymentIdAddressRequest) (*GetCompleteAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentIdAddress not implemented")
}
func (UnimplementedWalletServer) GetCompleteAddress(context.Context, *Empty) (*GetCompleteAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompleteAddress not implemented")
}
func (UnimplementedWalletServer) Transfer(context.Context, *TransferRequest) (*TransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedWalletServer) GetTransactionInfo(context.Context, *GetTransactionInfoRequest) (*GetTransactionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionInfo not implemented")
}
func (UnimplementedWalletServer) GetCompletedTransactions(*GetCompletedTransactionsRequest, Wallet_GetCompletedTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCompletedTransactions not implemented")
}
func (UnimplementedWalletServer) GetBlockHeightTransactions(context.Context, *GetBlockHeightTransactionsRequest) (*GetBlockHeightTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockHeightTransactions not implemented")
}
func (UnimplementedWalletServer) GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedWalletServer) GetUnspentAmounts(context.Context, *Empty) (*GetUnspentAmountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnspentAmounts not implemented")
}
func (UnimplementedWalletServer) CoinSplit(context.Context, *CoinSplitRequest) (*CoinSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoinSplit not implemented")
}
func (UnimplementedWalletServer) ImportUtxos(context.Context, *ImportUtxosRequest) (*ImportUtxosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportUtxos not implemented")
}
func (UnimplementedWalletServer) GetNetworkStatus(context.Context, *Empty) (*NetworkStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkStatus not implemented")
}
func (UnimplementedWalletServer) ListConnectedPeers(context.Context, *Empty) (*ListConnectedPeersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConnectedPeers not implemented")
}
func (UnimplementedWalletServer) CancelTransaction(context.Context, *CancelTransactionRequest) (*CancelTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTransaction not implemented")
}
func (UnimplementedWalletServer) RevalidateAllTransactions(context.Context, *RevalidateRequest) (*RevalidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevalidateAllTransactions not implemented")
}
func (UnimplementedWalletServer) ValidateAllTransactions(context.Context, *ValidateRequest) (*ValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAllTransactions not implemented")
}
func (UnimplementedWalletServer) SendShaAtomicSwapTransaction(context.Context, *SendShaAtomicSwapRequest) (*SendShaAtomicSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendShaAtomicSwapTransaction not implemented")
}
func (UnimplementedWalletServer) CreateBurnTransaction(context.Context, *CreateBurnTransactionRequest) (*CreateBurnTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBurnTransaction not implemented")
}
func (UnimplementedWalletServer) ClaimShaAtomicSwapTransaction(context.Context, *ClaimShaAtomicSwapRequest) (*ClaimShaAtomicSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimShaAtomicSwapTransaction not implemented")
}
func (UnimplementedWalletServer) ClaimHtlcRefundTransaction(context.Context, *ClaimHtlcRefundRequest) (*ClaimHtlcRefundResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimHtlcRefundTransaction not implemented")
}
func (UnimplementedWalletServer) CreateTemplateRegistration(context.Context, *CreateTemplateRegistrationRequest) (*CreateTemplateRegistrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTemplateRegistration not implemented")
}
func (UnimplementedWalletServer) SetBaseNode(context.Context, *SetBaseNodeRequest) (*SetBaseNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBaseNode not implemented")
}
func (UnimplementedWalletServer) StreamTransactionEvents(*TransactionEventRequest, Wallet_StreamTransactionEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamTransactionEvents not implemented")
}
func (UnimplementedWalletServer) RegisterValidatorNode(context.Context, *RegisterValidatorNodeRequest) (*RegisterValidatorNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterValidatorNode not implemented")
}
func (UnimplementedWalletServer) ImportTransactions(context.Context, *ImportTransactionsRequest) (*ImportTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportTransactions not implemented")
}
func (UnimplementedWalletServer) mustEmbedUnimplementedWalletServer() {}

// UnsafeWalletServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WalletServer will
// result in compilation errors.
type UnsafeWalletServer interface {
	mustEmbedUnimplementedWalletServer()
}

func RegisterWalletServer(s *grpc.Server, srv WalletServer) {
	s.RegisterService(&_Wallet_serviceDesc, srv)
}

func _Wallet_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetState(ctx, req.(*GetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CheckConnectivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CheckConnectivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/CheckConnectivity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CheckConnectivity(ctx, req.(*GetConnectivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CheckForUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CheckForUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/CheckForUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CheckForUpdates(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_Identify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).Identify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/Identify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).Identify(ctx, req.(*GetIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetAddress(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetPaymentIdAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentIdAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetPaymentIdAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetPaymentIdAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetPaymentIdAddress(ctx, req.(*GetPaymentIdAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetCompleteAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetCompleteAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetCompleteAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetCompleteAddress(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/Transfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).Transfer(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetTransactionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetTransactionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetTransactionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetTransactionInfo(ctx, req.(*GetTransactionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetCompletedTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetCompletedTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServer).GetCompletedTransactions(m, &walletGetCompletedTransactionsServer{stream})
}

type Wallet_GetCompletedTransactionsServer interface {
	Send(*GetCompletedTransactionsResponse) error
	grpc.ServerStream
}

type walletGetCompletedTransactionsServer struct {
	grpc.ServerStream
}

func (x *walletGetCompletedTransactionsServer) Send(m *GetCompletedTransactionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Wallet_GetBlockHeightTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockHeightTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetBlockHeightTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetBlockHeightTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetBlockHeightTransactions(ctx, req.(*GetBlockHeightTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetUnspentAmounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetUnspentAmounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetUnspentAmounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetUnspentAmounts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CoinSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoinSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CoinSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/CoinSplit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CoinSplit(ctx, req.(*CoinSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ImportUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ImportUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/ImportUtxos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ImportUtxos(ctx, req.(*ImportUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetNetworkStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetNetworkStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/GetNetworkStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetNetworkStatus(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ListConnectedPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ListConnectedPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/ListConnectedPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ListConnectedPeers(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CancelTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CancelTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/CancelTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CancelTransaction(ctx, req.(*CancelTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_RevalidateAllTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevalidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).RevalidateAllTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/RevalidateAllTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).RevalidateAllTransactions(ctx, req.(*RevalidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ValidateAllTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ValidateAllTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/ValidateAllTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ValidateAllTransactions(ctx, req.(*ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_SendShaAtomicSwapTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendShaAtomicSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).SendShaAtomicSwapTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/SendShaAtomicSwapTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).SendShaAtomicSwapTransaction(ctx, req.(*SendShaAtomicSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CreateBurnTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBurnTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CreateBurnTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/CreateBurnTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CreateBurnTransaction(ctx, req.(*CreateBurnTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ClaimShaAtomicSwapTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimShaAtomicSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ClaimShaAtomicSwapTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ClaimShaAtomicSwapTransaction(ctx, req.(*ClaimShaAtomicSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ClaimHtlcRefundTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimHtlcRefundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ClaimHtlcRefundTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/ClaimHtlcRefundTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ClaimHtlcRefundTransaction(ctx, req.(*ClaimHtlcRefundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CreateTemplateRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTemplateRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CreateTemplateRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/CreateTemplateRegistration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CreateTemplateRegistration(ctx, req.(*CreateTemplateRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_SetBaseNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBaseNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).SetBaseNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/SetBaseNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).SetBaseNode(ctx, req.(*SetBaseNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_StreamTransactionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TransactionEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServer).StreamTransactionEvents(m, &walletStreamTransactionEventsServer{stream})
}

type Wallet_StreamTransactionEventsServer interface {
	Send(*TransactionEventResponse) error
	grpc.ServerStream
}

type walletStreamTransactionEventsServer struct {
	grpc.ServerStream
}

func (x *walletStreamTransactionEventsServer) Send(m *TransactionEventResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Wallet_RegisterValidatorNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterValidatorNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).RegisterValidatorNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/RegisterValidatorNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).RegisterValidatorNode(ctx, req.(*RegisterValidatorNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ImportTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ImportTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tari.rpc.Wallet/ImportTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ImportTransactions(ctx, req.(*ImportTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Wallet_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tari.rpc.Wallet",
	HandlerType: (*WalletServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _Wallet_GetVersion_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _Wallet_GetState_Handler,
		},
		{
			MethodName: "CheckConnectivity",
			Handler:    _Wallet_CheckConnectivity_Handler,
		},
		{
			MethodName: "CheckForUpdates",
			Handler:    _Wallet_CheckForUpdates_Handler,
		},
		{
			MethodName: "Identify",
			Handler:    _Wallet_Identify_Handler,
		},
		{
			MethodName: "GetAddress",
			Handler:    _Wallet_GetAddress_Handler,
		},
		{
			MethodName: "GetPaymentIdAddress",
			Handler:    _Wallet_GetPaymentIdAddress_Handler,
		},
		{
			MethodName: "GetCompleteAddress",
			Handler:    _Wallet_GetCompleteAddress_Handler,
		},
		{
			MethodName: "Transfer",
			Handler:    _Wallet_Transfer_Handler,
		},
		{
			MethodName: "GetTransactionInfo",
			Handler:    _Wallet_GetTransactionInfo_Handler,
		},
		{
			MethodName: "GetBlockHeightTransactions",
			Handler:    _Wallet_GetBlockHeightTransactions_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _Wallet_GetBalance_Handler,
		},
		{
			MethodName: "GetUnspentAmounts",
			Handler:    _Wallet_GetUnspentAmounts_Handler,
		},
		{
			MethodName: "CoinSplit",
			Handler:    _Wallet_CoinSplit_Handler,
		},
		{
			MethodName: "ImportUtxos",
			Handler:    _Wallet_ImportUtxos_Handler,
		},
		{
			MethodName: "GetNetworkStatus",
			Handler:    _Wallet_GetNetworkStatus_Handler,
		},
		{
			MethodName: "ListConnectedPeers",
			Handler:    _Wallet_ListConnectedPeers_Handler,
		},
		{
			MethodName: "CancelTransaction",
			Handler:    _Wallet_CancelTransaction_Handler,
		},
		{
			MethodName: "RevalidateAllTransactions",
			Handler:    _Wallet_RevalidateAllTransactions_Handler,
		},
		{
			MethodName: "ValidateAllTransactions",
			Handler:    _Wallet_ValidateAllTransactions_Handler,
		},
		{
			MethodName: "SendShaAtomicSwapTransaction",
			Handler:    _Wallet_SendShaAtomicSwapTransaction_Handler,
		},
		{
			MethodName: "CreateBurnTransaction",
			Handler:    _Wallet_CreateBurnTransaction_Handler,
		},
		{
			MethodName: "ClaimShaAtomicSwapTransaction",
			Handler:    _Wallet_ClaimShaAtomicSwapTransaction_Handler,
		},
		{
			MethodName: "ClaimHtlcRefundTransaction",
			Handler:    _Wallet_ClaimHtlcRefundTransaction_Handler,
		},
		{
			MethodName: "CreateTemplateRegistration",
			Handler:    _Wallet_CreateTemplateRegistration_Handler,
		},
		{
			MethodName: "SetBaseNode",
			Handler:    _Wallet_SetBaseNode_Handler,
		},
		{
			MethodName: "RegisterValidatorNode",
			Handler:    _Wallet_RegisterValidatorNode_Handler,
		},
		{
			MethodName: "ImportTransactions",
			Handler:    _Wallet_ImportTransactions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetCompletedTransactions",
			Handler:       _Wallet_GetCompletedTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamTransactionEvents",
			Handler:       _Wallet_StreamTransactionEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "wallet.proto",
}
