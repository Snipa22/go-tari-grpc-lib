// Copyright 2020. The Tari Project
//
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
// following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
// disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
// following disclaimer in the documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
// products derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
// USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: wallet.proto

package tari_generated

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	Wallet_GetVersion_FullMethodName                           = "/tari.rpc.Wallet/GetVersion"
	Wallet_GetState_FullMethodName                             = "/tari.rpc.Wallet/GetState"
	Wallet_CheckConnectivity_FullMethodName                    = "/tari.rpc.Wallet/CheckConnectivity"
	Wallet_CheckForUpdates_FullMethodName                      = "/tari.rpc.Wallet/CheckForUpdates"
	Wallet_Identify_FullMethodName                             = "/tari.rpc.Wallet/Identify"
	Wallet_GetAddress_FullMethodName                           = "/tari.rpc.Wallet/GetAddress"
	Wallet_GetPaymentIdAddress_FullMethodName                  = "/tari.rpc.Wallet/GetPaymentIdAddress"
	Wallet_GetCompleteAddress_FullMethodName                   = "/tari.rpc.Wallet/GetCompleteAddress"
	Wallet_PrepareOneSidedTransactionForSigning_FullMethodName = "/tari.rpc.Wallet/PrepareOneSidedTransactionForSigning"
	Wallet_BroadcastSignedOneSidedTransaction_FullMethodName   = "/tari.rpc.Wallet/BroadcastSignedOneSidedTransaction"
	Wallet_Transfer_FullMethodName                             = "/tari.rpc.Wallet/Transfer"
	Wallet_GetTransactionInfo_FullMethodName                   = "/tari.rpc.Wallet/GetTransactionInfo"
	Wallet_GetCompletedTransactions_FullMethodName             = "/tari.rpc.Wallet/GetCompletedTransactions"
	Wallet_GetBlockHeightTransactions_FullMethodName           = "/tari.rpc.Wallet/GetBlockHeightTransactions"
	Wallet_GetTransactionPayRefs_FullMethodName                = "/tari.rpc.Wallet/GetTransactionPayRefs"
	Wallet_GetBalance_FullMethodName                           = "/tari.rpc.Wallet/GetBalance"
	Wallet_GetUnspentAmounts_FullMethodName                    = "/tari.rpc.Wallet/GetUnspentAmounts"
	Wallet_CoinSplit_FullMethodName                            = "/tari.rpc.Wallet/CoinSplit"
	Wallet_ImportUtxos_FullMethodName                          = "/tari.rpc.Wallet/ImportUtxos"
	Wallet_GetNetworkStatus_FullMethodName                     = "/tari.rpc.Wallet/GetNetworkStatus"
	Wallet_GetConnectedHttpPeer_FullMethodName                 = "/tari.rpc.Wallet/GetConnectedHttpPeer"
	Wallet_CancelTransaction_FullMethodName                    = "/tari.rpc.Wallet/CancelTransaction"
	Wallet_RevalidateAllTransactions_FullMethodName            = "/tari.rpc.Wallet/RevalidateAllTransactions"
	Wallet_ValidateAllTransactions_FullMethodName              = "/tari.rpc.Wallet/ValidateAllTransactions"
	Wallet_SendShaAtomicSwapTransaction_FullMethodName         = "/tari.rpc.Wallet/SendShaAtomicSwapTransaction"
	Wallet_CreateBurnTransaction_FullMethodName                = "/tari.rpc.Wallet/CreateBurnTransaction"
	Wallet_ClaimShaAtomicSwapTransaction_FullMethodName        = "/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction"
	Wallet_ClaimHtlcRefundTransaction_FullMethodName           = "/tari.rpc.Wallet/ClaimHtlcRefundTransaction"
	Wallet_CreateTemplateRegistration_FullMethodName           = "/tari.rpc.Wallet/CreateTemplateRegistration"
	Wallet_SignMessage_FullMethodName                          = "/tari.rpc.Wallet/SignMessage"
	Wallet_StreamTransactionEvents_FullMethodName              = "/tari.rpc.Wallet/StreamTransactionEvents"
	Wallet_ImportTransactions_FullMethodName                   = "/tari.rpc.Wallet/ImportTransactions"
	Wallet_GetAllCompletedTransactions_FullMethodName          = "/tari.rpc.Wallet/GetAllCompletedTransactions"
	Wallet_GetAllCompletedTransactionsStream_FullMethodName    = "/tari.rpc.Wallet/GetAllCompletedTransactionsStream"
	Wallet_GetPaymentByReference_FullMethodName                = "/tari.rpc.Wallet/GetPaymentByReference"
	Wallet_GetFeeEstimate_FullMethodName                       = "/tari.rpc.Wallet/GetFeeEstimate"
	Wallet_GetFeePerGramStats_FullMethodName                   = "/tari.rpc.Wallet/GetFeePerGramStats"
	Wallet_ReplaceByFee_FullMethodName                         = "/tari.rpc.Wallet/ReplaceByFee"
	Wallet_UserPayForFee_FullMethodName                        = "/tari.rpc.Wallet/UserPayForFee"
	Wallet_RegisterValidatorNode_FullMethodName                = "/tari.rpc.Wallet/RegisterValidatorNode"
	Wallet_SubmitValidatorEvictionProof_FullMethodName         = "/tari.rpc.Wallet/SubmitValidatorEvictionProof"
	Wallet_SubmitValidatorNodeExit_FullMethodName              = "/tari.rpc.Wallet/SubmitValidatorNodeExit"
)

// WalletClient is the client API for Wallet service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WalletClient interface {
	GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error)
	// Returns the current operational state of the wallet.
	//
	// This RPC provides an overview of the wallet's internal status, including:
	// - The latest blockchain height scanned by the wallet
	// - The current balance (available, pending incoming/outgoing)
	// - Network connectivity status with the base node
	//
	// This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
	// synchronized, and connected to the Tari network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.getState({});
	// console.log(response.scanned_height); // e.g., 1523493
	// console.log(response.balance.available_balance); // e.g., 1234567890
	// console.log(response.network.status); // e.g., "Online"
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "scanned_height": 1523493,
	//	  "balance": {
	//	    "available_balance": 1234567890,
	//	    "pending_incoming_balance": 100000000,
	//	    "pending_outgoing_balance": 0
	//	  },
	//	  "network": {
	//	    "status": "Online",
	//	    "avg_latency_ms": 28,
	//	    "num_node_connections": 8
	//	  }
	//	}
	//
	// ```
	GetState(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateResponse, error)
	// This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.checkConnectivity({});
	// console.log(response.status); // e.g., 1 (Online)
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "status": "Online"
	//	}
	//
	// ```
	CheckConnectivity(ctx context.Context, in *GetConnectivityRequest, opts ...grpc.CallOption) (*CheckConnectivityResponse, error)
	// Check for new updates
	CheckForUpdates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SoftwareUpdate, error)
	// The `Identify` RPC call returns the identity information of the wallet node.
	// This includes:
	// - **Public Key**: The wallet's cryptographic public key.
	// - **Public Address**: This will always be empty as the wallet has no contactable public comms address.
	// - **Node ID**: The unique identifier of the wallet node in the network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// // Call the Identify RPC method
	//
	//	client.Identify({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Identity Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	  "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
	//	  "public_address": "",
	//	  "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
	//	}
	//
	// ```
	Identify(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error)
	// This RPC returns two types of wallet addresses: interactive and one-sided addresses.
	// It provides these addresses in byte format as part of the response.
	// - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
	// - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
	//
	// Example usage (JavaScript):
	// // Call the GetAddress RPC method
	//
	//	client.GetAddress({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	//	// ```json
	//
	//	{
	//	  "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
	//	  "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
	//	}
	//
	// ```
	GetAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAddressResponse, error)
	// This RPC returns addresses generated for a specific payment ID. It provides both the interactive
	// and one-sided addresses for the given payment ID, along with their respective representations in
	// base58 and emoji formats.
	//
	// Example usage (JavaScript):
	//
	// ```javascript
	// // Prepare the payment ID for the request
	// const paymentId = Buffer.from('your_payment_id_here', 'hex');
	// const request = { payment_id: paymentId };
	//
	// // Call the GetPaymentIdAddress RPC method
	//
	//	client.GetPaymentIdAddress(request, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Payment ID Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "ðŸ¢ðŸŒŠðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸž.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­",
	//	 "one_sided_address_emoji": "ðŸ¢ðŸ“ŸðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸžðŸ“œ.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­"
	//	}
	//
	// ```
	GetPaymentIdAddress(ctx context.Context, in *GetPaymentIdAddressRequest, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error)
	// This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
	// The response includes:
	// - Raw binary
	// - Base58-encoded (human-readable)
	// - Emoji-encoded (for fun and friendliness)
	//
	// Example usage (JavaScript with gRPC):
	//
	// ```js
	// const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
	//
	//	client.getCompleteAddress({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// Sample response:
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "ðŸ¢ðŸŒŠðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸž.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­",
	//	 "one_sided_address_emoji": "ðŸ¢ðŸ“ŸðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸžðŸ“œ.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­"
	//	}
	//
	// ```
	GetCompleteAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error)
	PrepareOneSidedTransactionForSigning(ctx context.Context, in *PrepareOneSidedTransactionForSigningRequest, opts ...grpc.CallOption) (*PrepareOneSidedTransactionForSigningResponse, error)
	BroadcastSignedOneSidedTransaction(ctx context.Context, in *BroadcastSignedOneSidedTransactionRequest, opts ...grpc.CallOption) (*BroadcastSignedOneSidedTransactionResponse, error)
	// This call supports standard interactive transactions (Mimblewimble),
	// one-sided transactions, and one-sided-to-stealth-address transactions.
	// Each recipient must include a valid Tari address, amount, fee, and payment type.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const recipient = new PaymentRecipient();
	// recipient.setAddress("14HVCEeZ...");
	// recipient.setAmount(1000000); // 1 T
	// recipient.setFeePerGram(25);
	// recipient.setPaymentType(PaymentType.ONE_SIDED);
	// recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
	//
	// const request = new TransferRequest();
	// request.setRecipientsList([recipient]);
	//
	//	client.transfer(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.toObject());
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "results": [
	//	    {
	//	      "address": "14HVCEeZ...",
	//	      "transaction_id": 12345,
	//	      "is_success": true,
	//	      "failure_message": ""
	//	    }
	//	  ]
	//	}
	Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error)
	// Returns the transaction details for the given transaction IDs.
	//
	// The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
	// The response includes details such as transaction status, direction, amount, fee, and more.
	//
	// ### Request Parameters:
	//
	// - `transaction_ids` (required):
	//   - **Type**: `repeated uint64`
	//   - **Description**: A list of transaction IDs to query.
	//   - **Restrictions**:
	//   - Must contain at least one ID.
	//   - All IDs must be valid unsigned 64-bit integers.
	//   - Duplicates will be ignored; only the first occurrence is processed.
	//   - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { transaction_ids: [12345, 67890] };
	//
	//	client.getTransactionInfo(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.transactions);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_OUTBOUND",
	//	      "amount": 1000000,
	//	      "fee": 25,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	GetTransactionInfo(ctx context.Context, in *GetTransactionInfoRequest, opts ...grpc.CallOption) (*GetTransactionInfoResponse, error)
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-001"
	//	  }
	//	};
	//
	// const call = client.getCompletedTransactions(request);
	//
	//	call.on('data', (response) => {
	//	  console.log(response.transaction);
	//	});
	//
	// call.on('error', console.error);
	// call.on('end', () => console.log("Stream ended"));
	// ```
	//
	// ### Sample Streamed JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 12345,
	//	    "source_address": "0x1234abcd...",
	//	    "dest_address": "0x5678efgh...",
	//	    "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	    "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	    "amount": 500000,
	//	    "fee": 20,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0xabcdef...",
	//	    "timestamp": 1681234567,
	//	    "payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 1523493
	//	  }
	//	}
	//
	// ```
	GetCompletedTransactions(ctx context.Context, in *GetCompletedTransactionsRequest, opts ...grpc.CallOption) (Wallet_GetCompletedTransactionsClient, error)
	// Returns all transactions that were mined at a specific block height.
	//
	// The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
	// at the specified block height. The response includes all transactions in a single response,
	// with each transaction including details such as status, direction, amount,
	// fees, and associated metadata.
	//
	// ### Request Parameters:
	//
	// - `block_height` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The specific block height to fetch transactions for.
	//   - **Restrictions**:
	//   - Must be a valid block height (greater than 0).
	//   - If the block height is beyond the current chain height, no transactions will be returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  block_height: 1523493
	//	};
	//
	// const response = await client.getBlockHeightTransactions(request);
	// console.log(response.transactions);
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	      "amount": 500000,
	//	      "fee": 20,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	//
	// ```
	GetBlockHeightTransactions(ctx context.Context, in *GetBlockHeightTransactionsRequest, opts ...grpc.CallOption) (*GetBlockHeightTransactionsResponse, error)
	// Returns all PayRefs (payment references) for a specific transaction.
	//
	// The `GetTransactionPayRefs` call retrieves all PayRefs associated with the specified
	// transaction ID. PayRefs are cryptographic references generated from output hashes
	// that allow recipients to verify payments without revealing sensitive transaction details.
	//
	// ### Request Parameters:
	//
	// - `transaction_id` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The transaction ID to retrieve PayRefs for.
	//   - **Restrictions**:
	//   - Must be a valid transaction ID that exists in the wallet.
	//   - If the transaction ID is invalid or not found, an error will be returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  transaction_id: 12345
	//	};
	//
	// const response = await client.getTransactionPayRefs(request);
	// console.log("PayRefs:", response.payment_references.map(ref => Buffer.from(ref).toString('hex')));
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "payment_references": [
	//	    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
	//	    "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
	//	  ]
	//	}
	//
	// ```
	GetTransactionPayRefs(ctx context.Context, in *GetTransactionPayRefsRequest, opts ...grpc.CallOption) (*GetTransactionPayRefsResponse, error)
	// Returns the wallet balance details.
	//
	// The `GetBalance` call retrieves the current balance status of the wallet,
	// optionally filtered by a specific `payment_id`. The response includes detailed
	// breakdowns of available, pending incoming/outgoing, and timelocked balances.
	//
	// ### Request Parameters:
	//
	// - `payment_id` (optional):
	//   - **Type**: `UserPaymentId` (one of several formats).
	//   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
	//   - **Accepted Formats** (must provide **only one**):
	//   - `u256`: a 32-byte hexadecimal identifier.
	//   - `utf8_string`: a human-readable string ID.
	//   - `user_bytes`: raw binary bytes.
	//   - **Restrictions**:
	//   - Only one format must be provided at a time.
	//   - If multiple or no formats are provided within `payment_id`, the request will return an error.
	//   - If `payment_id` is omitted, the total wallet balance is returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-002"
	//	  }
	//	};
	//
	//	client.getBalance(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Balance:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "available_balance": 950000,
	//	  "pending_incoming_balance": 200000,
	//	  "pending_outgoing_balance": 50000,
	//	  "timelocked_balance": 100000
	//	}
	//
	// ```
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	// Returns the total value of unspent outputs in the wallet.
	//
	// The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
	// currently held by the wallet. These are outputs that have not yet been spent or time-locked,
	// and are available for future transactions.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getUnspentAmounts({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Total unspent amount:", response.amount);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "amount": 1250000
	//	}
	//
	// ```
	GetUnspentAmounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetUnspentAmountsResponse, error)
	// Creates a transaction that splits funds into multiple smaller outputs.
	//
	// The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
	// This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
	// The resulting transaction is broadcast and can be tracked via its transaction ID.
	//
	// ### Request Parameters:
	//
	// - `amount_per_split` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The value of each individual output in the split.
	//   - **Restrictions**: Must be greater than zero.
	//
	// - `split_count` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The number of outputs to create.
	//   - **Restrictions**: Must be greater than zero and within practical system limits.
	//
	// - `fee_per_gram` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The transaction fee rate (per gram of weight).
	//   - **Restrictions**: Should be set high enough to ensure confirmation.
	//
	// - `lock_height` (optional):
	//   - **Type**: `uint64`
	//   - **Description**: The earliest block height at which the transaction becomes valid.
	//   - **Restrictions**: Defaults to 0 if not specified.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: A user-defined identifier for tracking or referencing the transaction.
	//   - **Restrictions**: Optional; can be left empty.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  amount_per_split: 100000,
	//	  split_count: 5,
	//	  fee_per_gram: 25,
	//	  lock_height: 0,
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.coinSplit(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Created CoinSplit Tx ID:", response.tx_id);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_id": 987654321
	//	}
	//
	// ```
	CoinSplit(ctx context.Context, in *CoinSplitRequest, opts ...grpc.CallOption) (*CoinSplitResponse, error)
	// Imports UTXOs into the wallet as spendable outputs.
	//
	// The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
	// into the wallet, marking them as spendable without needing rewindable metadata.
	// Each UTXO is associated with a transaction ID in the response.
	//
	// ### Request Parameters:
	//
	// - `outputs` (required):
	//   - **Type**: `repeated UnblindedOutput`
	//   - **Description**: A list of unblinded outputs to import into the wallet.
	//   - **Restrictions**:
	//   - Each output must be valid and convertible to an internal UTXO format.
	//   - The list must contain at least one item.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: An optional user-defined identifier to associate with the imported outputs.
	//   - **Restrictions**:
	//   - Can be left empty if not needed.
	//   - Must be a valid byte string if provided.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  outputs: [/* array of unblinded outputs */],
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.importUtxos(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Imported Tx IDs:", response.tx_ids);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_ids": [101, 102, 103]
	//	}
	//
	// ```
	ImportUtxos(ctx context.Context, in *ImportUtxosRequest, opts ...grpc.CallOption) (*ImportUtxosResponse, error)
	// Returns the wallet's current network connectivity status.
	//
	// The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
	// including whether it is online, the number of active peer connections, and the average latency
	// to the configured base node.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getNetworkStatus({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Network Status:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "status": "ONLINE",
	//	  "avg_latency_ms": 142,
	//	  "num_node_connections": 1
	//	}
	//
	// ```
	//
	// ### Status Field Values:
	//
	// The `status` field indicates the current network connectivity of the wallet. Possible values are:
	//
	// - `INITIALIZING`:
	//   - The wallet connectivity is busy initializing.
	//
	// - `ONLINE`:
	//   - The wallet is fully connected to the network and functioning normally.
	//
	// - `DEGRADED`:
	//   - The wallet is connected but has high latency.
	//   - This could indicate issues with network connectivity, such as as a congested network, leading to reduced
	//     performance or reliability.
	//
	// - `OFFLINE`:
	//   - The wallet is not connected to any peers.
	//   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
	GetNetworkStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NetworkStatusResponse, error)
	// Returns a list of HTTP peers currently connected to the wallet.
	//
	// The `GetConnectedHttpPeer` call retrieves information about the HTTP peer that the wallet is currently
	// connected to. The response is a `GetConnectedHttpPeerResponse` containing a list of `HttpPeer` objects.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Response Fields:
	//
	// - **connected_peers**: List of `HttpPeer` objects currently connected to the wallet.
	//   - **url**: The connection URL (string).
	//   - **last_latency**: The latency of the last request to this peer (`AverageLatency`).
	//   - **is_online**: Online status of the peer (bool).
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.GetConnectedHttpPeer({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Connected Peers:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "connected_peers": {
	//	      "url": "http://127.0.0.1:18080",
	//	      "last_latency": { "value": 42 },
	//	      "is_online": true
	//	   }
	//	}
	//
	// ```
	GetConnectedHttpPeer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConnectedHttpPeerResponse, error)
	// Cancels a specific transaction by its ID.
	//
	// The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
	// If the cancellation is successful, the response will indicate success. Otherwise, the response will
	// contain a failure message with the reason for the failure.
	//
	// ### Request Parameters:
	//
	// - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
	//
	// ### Response Fields:
	//
	// - **is_success**: A boolean indicating whether the cancellation was successful (bool).
	//   - `true` if the cancellation was successful, `false` if not.
	//
	// - **failure_message**: A string that provides the reason for the failure, if applicable (string).
	//   - This field will be empty if the cancellation was successful.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { tx_id: 12345 };
	//
	//	client.cancelTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	//
	// ```
	CancelTransaction(ctx context.Context, in *CancelTransactionRequest, opts ...grpc.CallOption) (*CancelTransactionResponse, error)
	// Will trigger a complete revalidation of all wallet outputs.
	RevalidateAllTransactions(ctx context.Context, in *RevalidateRequest, opts ...grpc.CallOption) (*RevalidateResponse, error)
	// Will trigger a validation of all wallet outputs.
	ValidateAllTransactions(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
	// Sends a XTR SHA Atomic Swap transaction.
	//
	// The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
	// transaction using SHA. It allows the sender to send a payment to the recipient
	// in exchange for an atomic swap, with SHA used as the secret for the swap.
	// The method accepts the recipient's information and initiates the transaction.
	//
	// ### Request Parameters:
	//   - **recipient** (required): A PaymentRecipient object containing the recipient's address,
	//     the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the transaction.
	// - **pre_image**: The SHA pre-image of the atomic swap.
	// - **output_hash**: The hash of the output associated with the transaction.
	// - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
	// - **failure_message**: Provides an error message if the transaction failed.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  recipient: {
	//	    address: "t1abc12345",
	//	    amount: 1000000,
	//	    fee_per_gram: 10,
	//	    payment_id: "0xdeadbeef"
	//	  }
	//	};
	//
	//	client.sendShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "pre_image": "0xabcdef1234567890",
	//	  "output_hash": "0x123456abcdef7890",
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	SendShaAtomicSwapTransaction(ctx context.Context, in *SendShaAtomicSwapRequest, opts ...grpc.CallOption) (*SendShaAtomicSwapResponse, error)
	// Creates a burn transaction for burning a specified amount of Tari currency.
	//
	// The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
	// by initiating a burn transaction. It allows the user to specify the amount to burn,
	// along with a fee per gram and optionally a payment ID and claim public key.
	//
	// ### Request Parameters:
	// - **amount** (required): The amount of Tari to be burned.
	// - **fee_per_gram** (required): The fee per gram for the transaction.
	// - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
	// - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the burn transaction.
	// - **is_success**: Indicates whether the burn transaction was successfully created.
	// - **failure_message**: Provides an error message if the transaction creation failed.
	// - **commitment**: The commitment associated with the burn transaction.
	// - **ownership_proof**: A proof of ownership for the burned coins.
	// - **range_proof**: The range proof associated with the burned coins.
	// - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  amount: 1000000,
	//	  fee_per_gram: 10,
	//	  claim_public_key: "0xabcdef1234567890",
	//	  payment_id: "0xdeadbeef"
	//	};
	//
	//	client.createBurnTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "is_success": true,
	//	  "failure_message": "",
	//	  "commitment": "0xcommitmenthash",
	//	  "ownership_proof": "0xownershipproof",
	//	  "range_proof": "0xrangeproof",
	//	  "reciprocal_claim_public_key": "0xreciprocalpublickey"
	//	}
	CreateBurnTransaction(ctx context.Context, in *CreateBurnTransactionRequest, opts ...grpc.CallOption) (*CreateBurnTransactionResponse, error)
	// Claims a SHA Atomic Swap transaction using a pre-image and output hash.
	//
	// The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
	// a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
	// previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
	// secret required to spend the output.
	//
	// ### Request Parameters:
	// - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
	// - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
	// - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
	//
	// ### Input Validation:
	// - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
	// - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
	// - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
	//	  pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
	//	  fee_per_gram: 10
	//	};
	//
	//	client.claimShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 789654,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimShaAtomicSwapTransaction(ctx context.Context, in *ClaimShaAtomicSwapRequest, opts ...grpc.CallOption) (*ClaimShaAtomicSwapResponse, error)
	// Claims an HTLC refund transaction after the timelock period has passed.
	//
	// The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
	// to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
	// This is possible only after the output's timelock has expired.
	//
	// ### Request Parameters:
	// - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
	// - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
	//
	// ### Input Validation:
	// - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
	// - `fee_per_gram` must be a non-zero `uint64` value.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output_hash: "aabbccddeeff0011...99",
	//	  fee_per_gram: 20
	//	};
	//
	//	client.claimHtlcRefundTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 889977,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimHtlcRefundTransaction(ctx context.Context, in *ClaimHtlcRefundRequest, opts ...grpc.CallOption) (*ClaimHtlcRefundResponse, error)
	// Creates a transaction with a template registration output
	CreateTemplateRegistration(ctx context.Context, in *CreateTemplateRegistrationRequest, opts ...grpc.CallOption) (*CreateTemplateRegistrationResponse, error)
	// Signs a message using the wallet's node identity private key.
	//
	// The `SignMessage` call creates a Schnorr signature over a message using the wallet's node identity private key.
	// This signature can be used to prove ownership of the wallet or authenticate messages.
	// The signature is returned as separate components (signature and public nonce) for verification.
	//
	// ### Request Parameters:
	//
	// - `message` (required):
	//   - **Type**: `bytes`
	//   - **Description**: The message to be signed (arbitrary bytes).
	//   - **Restrictions**: Can be any byte sequence.
	//
	// ### Response Fields:
	//
	// - **signature**: The Schnorr signature as hex-encoded bytes.
	// - **public_nonce**: The public nonce component of the signature as hex-encoded bytes.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  message: Buffer.from("Hello Tari!", "utf-8")
	//	};
	//
	//	client.signMessage(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Signature:", response.signature, "Nonce:", response.public_nonce);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "signature": "a1b2c3d4e5f6...",
	//	  "public_nonce": "f6e5d4c3b2a1..."
	//	}
	//
	// ```
	//
	// ### Security Notes:
	//
	// - This signs with the wallet's node identity private key.
	// - The signature can be verified using the wallet's public key.
	// - Use this for authentication and ownership proofs only.
	SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error)
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	// const call = client.streamTransactionEvents({});
	//
	//	call.on("data", (response) => {
	//	  console.log("Transaction Event:", response.transaction);
	//	});
	//
	//	call.on("end", () => {
	//	  console.log("Stream ended.");
	//	});
	//
	//	call.on("error", (err) => {
	//	  console.error("Stream error:", err);
	//	});
	//
	// ```
	//
	// ### Sample JSON Streamed Response:
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "event": "Mined",
	//	    "tx_id": "103248",
	//	    "source_address": "0xabc123...",
	//	    "dest_address": "0xdef456...",
	//	    "status": "Completed",
	//	    "direction": "Outbound",
	//	    "amount": 100000000,
	//	    "payment_id": "0xdeadbeef..."
	//	  }
	//	}
	//
	// ```
	StreamTransactionEvents(ctx context.Context, in *TransactionEventRequest, opts ...grpc.CallOption) (Wallet_StreamTransactionEventsClient, error)
	ImportTransactions(ctx context.Context, in *ImportTransactionsRequest, opts ...grpc.CallOption) (*ImportTransactionsResponse, error)
	// Deprecated: Do not use.
	// Get all completed transactions including cancelled ones, sorted by timestamp and paginated
	// DEPRECATED: Use GetAllCompletedTransactionsStream for better performance and memory efficiency
	GetAllCompletedTransactions(ctx context.Context, in *GetAllCompletedTransactionsRequest, opts ...grpc.CallOption) (*GetAllCompletedTransactionsResponse, error)
	// Streams previously completed wallet transactions to the client.
	//
	// The `GetAllCompletedTransactionsStream` RPC provides a paginated, filtered stream of previously completed transactions
	// from the wallet database. Unlike real-time event streaming, this RPC allows clients to retrieve historical transaction
	// data using offset, limit, and optional status-based filtering.
	//
	// This is ideal for applications that need to display a transaction history, perform analytics, or resume from a known offset.
	//
	// ### Request Parameters:
	// - **offset** (uint64): The starting index in the list of completed transactions.
	// - **limit** (uint64): Maximum number of transactions to return. Capped at 50 per request.
	// - **status_bitflag** (uint64): Optional bitflag to filter transactions by status (e.g., mined, cancelled).
	//
	// ### Response Stream:
	// - Each message in the response stream is a `GetCompletedTransactionsResponse` containing:
	//   - **transaction**: A `TransactionInfo` object representing a completed wallet transaction.
	//
	// ### `TransactionInfo` Fields:
	// - **tx_id** (uint64): Unique transaction identifier.
	// - **source_address** (bytes): Sender address.
	// - **dest_address** (bytes): Recipient address.
	// - **status** (enum): Status of the transaction (`Completed`, `Mined`, `Cancelled`, etc.).
	// - **direction** (enum): `"Inbound"` or `"Outbound"`.
	// - **amount** (uint64): Transaction amount in microTari.
	// - **fee** (uint64): Transaction fee in microTari.
	// - **is_cancelled** (bool): Whether the transaction was cancelled.
	// - **excess_sig** (bytes): Signature of the transaction kernel excess.
	// - **timestamp** (uint64): UNIX timestamp of the transaction creation time.
	// - **raw_payment_id** (bytes): Raw payment ID used in the transaction.
	// - **user_payment_id** (bytes): User-visible payment ID, if applicable.
	// - **mined_in_block_height** (uint64): Block height where the transaction was mined. Zero if not mined.
	// - **input_commitments** (repeated bytes): Commitments for transaction inputs.
	// - **output_commitments** (repeated bytes): Commitments for transaction outputs.
	// - **payment_references_sent** (repeated bytes): Metadata references associated with sent outputs.
	// - **payment_references_received** (repeated bytes): Metadata references associated with received outputs.
	// - **payment_references_change** (repeated bytes): Metadata references associated with change outputs.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const call = client.getAllCompletedTransactionsStream({
	//	  offset: 0,
	//	  limit: 20,
	//	  status_bitflag: 0
	//	});
	//
	//	call.on("data", (response) => {
	//	  console.log("Completed Transaction:", response.transaction);
	//	});
	//
	//	call.on("end", () => {
	//	  console.log("Stream ended.");
	//	});
	//
	//	call.on("error", (err) => {
	//	  console.error("Stream error:", err);
	//	});
	//
	// ```
	//
	// ### Sample JSON Streamed Response:
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 103248,
	//	    "source_address": "0xabc123...",
	//	    "dest_address": "0xdef456...",
	//	    "status": "Completed",
	//	    "direction": "Outbound",
	//	    "amount": 100000000,
	//	    "fee": 200000,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0x...",
	//	    "timestamp": 1670000000,
	//	    "raw_payment_id": "0xdeadbeef...",
	//	    "user_payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 202000,
	//	    "input_commitments": ["0x...", "0x..."],
	//	    "output_commitments": ["0x...", "0x..."],
	//	    "payment_references_sent": ["0x...", "0x..."],
	//	    "payment_references_received": [],
	//	    "payment_references_change": []
	//	  }
	//	}
	//
	// ```
	GetAllCompletedTransactionsStream(ctx context.Context, in *GetAllCompletedTransactionsRequest, opts ...grpc.CallOption) (Wallet_GetAllCompletedTransactionsStreamClient, error)
	// Gets transaction information by payment reference (PayRef)
	//
	// The `GetPaymentByReference` call retrieves transaction information using a 32-byte payment reference hash.
	// PayRefs are generated as Blake2b_256(block_hash || output_hash) and provide a stable way to look up
	// transactions even after outputs are spent.
	//
	// ### Request Parameters:
	//
	// - `payment_reference` (required):
	//   - **Type**: `bytes` (32 bytes)
	//   - **Description**: The payment reference hash to look up
	//   - **Restrictions**: Must be exactly 32 bytes representing a valid PayRef
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const payref = Buffer.from('a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890', 'hex');
	// const request = { payment_reference: payref };
	//
	//	client.getPaymentByReference(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log('Transaction found:', response.transaction);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 12345,
	//	    "source_address": "0x1234abcd...",
	//	    "dest_address": "0x5678efgh...",
	//	    "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	    "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	    "amount": 1000000,
	//	    "fee": 20,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0xabcdef...",
	//	    "timestamp": 1681234567,
	//	    "payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 150000
	//	  }
	//	}
	//
	// ```
	GetPaymentByReference(ctx context.Context, in *GetPaymentByReferenceRequest, opts ...grpc.CallOption) (*GetPaymentByReferenceResponse, error)
	// Estimates the transaction fee based on amount, fee rate, and number of outputs.
	//
	// The `GetFeeEstimate` call allows clients to calculate the expected transaction fee before sending funds.
	// This is useful for presenting fee information to the user or for ensuring sufficient funds are available.
	//
	// ### Request Parameters:
	// - **amount** (required): The amount to send, in microTari. (1 Tari = 1,000,000 ÂµT).
	// - **fee_per_gram** (required): The fee per gram (weight unit) to use for the estimate. Higher values may improve priority.
	// - **output_count** (required): The number of outputs to create in the transaction (e.g., 2 = recipient + change).
	//
	// ### Input Validation:
	// - `amount` must be a non-zero `uint64` representing the amount to transfer.
	// - `fee_per_gram` must be a non-zero `uint64`; zero or low fees may result in delayed confirmation or failure.
	// - `output_count` must be convertible to a valid `usize`; large values may increase the fee significantly.
	//
	// ### Response Fields:
	// - **estimated_fee**: A `uint64` value representing the estimated total transaction fee in microTari.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  amount: 1000000,         // Sending 1 Tari
	//	  fee_per_gram: 5,         // Fee rate of 5 ÂµT/g
	//	  output_count: 2          // One recipient + one change output
	//	};
	//
	//	client.getFeeEstimate(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Estimated fee:", response.estimated_fee);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "estimated_fee": 12345
	//	}
	//
	// ```
	GetFeeEstimate(ctx context.Context, in *GetFeeEstimateRequest, opts ...grpc.CallOption) (*GetFeeEstimateResponse, error)
	// Retrieves fee-per-gram statistics over recent blocks.
	//
	// The `GetFeePerGramStats` call returns aggregated fee rate information to help clients
	// understand recent network fee trends. This can be used for setting appropriate fees
	// when constructing transactions.
	//
	// ### Request Parameters:
	//   - **block_count** (optional): The number of recent blocks to include in the statistics.
	//     If not specified or zero, a default number of blocks will be used.
	//
	// ### Input Validation:
	// - `block_count` must be a non-negative `uint64`. Large values may increase query time.
	//
	// ### Response Fields:
	// - **fee_per_gram_stats**: A list of `FeePerGramStat` objects summarizing fee data over the specified blocks.
	//
	// Each `FeePerGramStat` contains:
	// - **average_fee_per_gram**: Average fee per gram observed over the blocks.
	// - **min_fee_per_gram**: Minimum fee per gram observed.
	// - **max_fee_per_gram**: Maximum fee per gram observed.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  block_count: 10 // Consider fees over the last 10 blocks
	//	};
	//
	//	client.getFeePerGramStats(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else response.fee_per_gram_stats.forEach(stat => {
	//	    console.log(`Avg: ${stat.average_fee_per_gram}, Min: ${stat.min_fee_per_gram}, Max: ${stat.max_fee_per_gram}`);
	//	  });
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "fee_per_gram_stats": [
	//	    {
	//	      "average_fee_per_gram": 5,
	//	      "min_fee_per_gram": 3,
	//	      "max_fee_per_gram": 10
	//	    }
	//	  ]
	//	}
	//
	// ```
	GetFeePerGramStats(ctx context.Context, in *GetFeePerGramStatsRequest, opts ...grpc.CallOption) (*GetFeePerGramStatsResponse, error)
	// Attempts to replace an existing transaction with a new one that has a higher fee.
	//
	// The `ReplaceByFee` call enables clients to increase the fee of a pending transaction,
	// potentially speeding up its confirmation by incentivizing miners to prioritize it.
	//
	// ### Request Parameters:
	//   - **transaction_id** (required): The ID of the original transaction to replace.
	//   - **fee_increase** (required): The additional fee amount to add, specified in microTari.
	//     Must be greater than zero.
	//
	// ### Input Validation:
	// - `transaction_id` must correspond to a currently unconfirmed transaction.
	// - `fee_increase` must be a non-zero `uint64`. Zero or negative values are invalid.
	//
	// ### Response Fields:
	// - **transaction_id**: The transaction ID of the new replacement transaction.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  transaction_id: 123456,
	//	  fee_increase: 5000  // Increase fee by 5,000 microTari
	//	};
	//
	//	client.replaceByFee(request, (err, response) => {
	//	  if (err) console.error("Failed to replace by fee:", err);
	//	  else console.log("Replacement transaction ID:", response.transaction_id);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 7891011
	//	}
	//
	// ```
	ReplaceByFee(ctx context.Context, in *ReplaceByFeeRequest, opts ...grpc.CallOption) (*ReplaceByFeeResponse, error)
	// Allows users to pay a specified fee for spending transaction outputs to given recipients.
	//
	// The `UserPayForFee` call enables clients to request that the wallet pays the fee
	// for one or more transactions identified by their IDs, sending funds to the specified recipients.
	// This is useful for fee bumping or covering transaction fees on behalf of recipients.
	//
	// ### Request Parameters:
	// - **recipients** (required): A list of transfers, each specifying:
	//   - `tx_id`: The transaction ID whose outputs will be spent.
	//   - `fee`: The fee amount in microTari to pay for this transfer.
	//   - `destination`: The Base58-encoded Tari address of the recipient.
	//
	// ### Input Validation:
	// - Each `tx_id` must correspond to a valid transaction whose outputs can be spent.
	// - Each `fee` must be a non-negative uint64 specifying the fee to pay.
	// - Each `destination` must be a valid Base58 Tari address.
	//
	// ### Response Fields:
	// - **results**: A list of `TransferResult` objects, one per requested recipient, each containing:
	//   - `address`: The recipient address as a string.
	//   - `transaction_id`: The ID of the newly created transaction (or zero if failed).
	//   - `is_success`: Boolean indicating if the fee payment transaction succeeded.
	//   - `failure_message`: A string describing the error if the transaction failed.
	//   - `transaction_info`: Detailed transaction metadata if available.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  recipients: [
	//	    {
	//	      tx_id: 123,
	//	      fee: 1000,
	//	      destination: "tari1qxyz..."
	//	    },
	//	    {
	//	      tx_id: 456,
	//	      fee: 2000,
	//	      destination: "tari1qabcd..."
	//	    }
	//	  ]
	//	};
	//
	//	client.userPayForFee(request, (err, response) => {
	//	  if (err) console.error("Fee payment failed:", err);
	//	  else {
	//	    response.results.forEach(result => {
	//	      if (result.is_success) {
	//	        console.log(`Fee paid successfully to ${result.address} in tx ${result.transaction_id}`);
	//	      } else {
	//	        console.error(`Failed to pay fee for ${result.address}: ${result.failure_message}`);
	//	      }
	//	    });
	//	  }
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": [
	//	    {
	//	      "address": "tari1qxyz...",
	//	      "transaction_id": 789,
	//	      "is_success": true,
	//	      "failure_message": "",
	//	      "transaction_info": {
	//	        "tx_id": 789,
	//	        "source_address": "...",
	//	        "dest_address": "...",
	//	        "status": "Completed",
	//	        "direction": "Outbound",
	//	        "amount": 50000,
	//	        "fee": 1000,
	//	        "is_cancelled": false,
	//	        "timestamp": 1620000000
	//	      }
	//	    },
	//	    {
	//	      "address": "tari1qabcd...",
	//	      "transaction_id": 0,
	//	      "is_success": false,
	//	      "failure_message": "Invalid destination address",
	//	      "transaction_info": null
	//	    }
	//	  ]
	//	}
	//
	// ```
	UserPayForFee(ctx context.Context, in *UserPayForFeeRequest, opts ...grpc.CallOption) (*UserPayForFeeResponse, error)
	RegisterValidatorNode(ctx context.Context, in *RegisterValidatorNodeRequest, opts ...grpc.CallOption) (*RegisterValidatorNodeResponse, error)
	SubmitValidatorEvictionProof(ctx context.Context, in *SubmitValidatorEvictionProofRequest, opts ...grpc.CallOption) (*SubmitValidatorEvictionProofResponse, error)
	SubmitValidatorNodeExit(ctx context.Context, in *SubmitValidatorNodeExitRequest, opts ...grpc.CallOption) (*SubmitValidatorNodeExitResponse, error)
}

type walletClient struct {
	cc grpc.ClientConnInterface
}

func NewWalletClient(cc grpc.ClientConnInterface) WalletClient {
	return &walletClient{cc}
}

func (c *walletClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*GetVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVersionResponse)
	err := c.cc.Invoke(ctx, Wallet_GetVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetState(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStateResponse)
	err := c.cc.Invoke(ctx, Wallet_GetState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CheckConnectivity(ctx context.Context, in *GetConnectivityRequest, opts ...grpc.CallOption) (*CheckConnectivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckConnectivityResponse)
	err := c.cc.Invoke(ctx, Wallet_CheckConnectivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CheckForUpdates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SoftwareUpdate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SoftwareUpdate)
	err := c.cc.Invoke(ctx, Wallet_CheckForUpdates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) Identify(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIdentityResponse)
	err := c.cc.Invoke(ctx, Wallet_Identify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAddressResponse)
	err := c.cc.Invoke(ctx, Wallet_GetAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetPaymentIdAddress(ctx context.Context, in *GetPaymentIdAddressRequest, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCompleteAddressResponse)
	err := c.cc.Invoke(ctx, Wallet_GetPaymentIdAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetCompleteAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetCompleteAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCompleteAddressResponse)
	err := c.cc.Invoke(ctx, Wallet_GetCompleteAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) PrepareOneSidedTransactionForSigning(ctx context.Context, in *PrepareOneSidedTransactionForSigningRequest, opts ...grpc.CallOption) (*PrepareOneSidedTransactionForSigningResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareOneSidedTransactionForSigningResponse)
	err := c.cc.Invoke(ctx, Wallet_PrepareOneSidedTransactionForSigning_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) BroadcastSignedOneSidedTransaction(ctx context.Context, in *BroadcastSignedOneSidedTransactionRequest, opts ...grpc.CallOption) (*BroadcastSignedOneSidedTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BroadcastSignedOneSidedTransactionResponse)
	err := c.cc.Invoke(ctx, Wallet_BroadcastSignedOneSidedTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferResponse)
	err := c.cc.Invoke(ctx, Wallet_Transfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetTransactionInfo(ctx context.Context, in *GetTransactionInfoRequest, opts ...grpc.CallOption) (*GetTransactionInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionInfoResponse)
	err := c.cc.Invoke(ctx, Wallet_GetTransactionInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetCompletedTransactions(ctx context.Context, in *GetCompletedTransactionsRequest, opts ...grpc.CallOption) (Wallet_GetCompletedTransactionsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Wallet_ServiceDesc.Streams[0], Wallet_GetCompletedTransactions_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &walletGetCompletedTransactionsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Wallet_GetCompletedTransactionsClient interface {
	Recv() (*GetCompletedTransactionsResponse, error)
	grpc.ClientStream
}

type walletGetCompletedTransactionsClient struct {
	grpc.ClientStream
}

func (x *walletGetCompletedTransactionsClient) Recv() (*GetCompletedTransactionsResponse, error) {
	m := new(GetCompletedTransactionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *walletClient) GetBlockHeightTransactions(ctx context.Context, in *GetBlockHeightTransactionsRequest, opts ...grpc.CallOption) (*GetBlockHeightTransactionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBlockHeightTransactionsResponse)
	err := c.cc.Invoke(ctx, Wallet_GetBlockHeightTransactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetTransactionPayRefs(ctx context.Context, in *GetTransactionPayRefsRequest, opts ...grpc.CallOption) (*GetTransactionPayRefsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTransactionPayRefsResponse)
	err := c.cc.Invoke(ctx, Wallet_GetTransactionPayRefs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, Wallet_GetBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetUnspentAmounts(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetUnspentAmountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUnspentAmountsResponse)
	err := c.cc.Invoke(ctx, Wallet_GetUnspentAmounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CoinSplit(ctx context.Context, in *CoinSplitRequest, opts ...grpc.CallOption) (*CoinSplitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CoinSplitResponse)
	err := c.cc.Invoke(ctx, Wallet_CoinSplit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ImportUtxos(ctx context.Context, in *ImportUtxosRequest, opts ...grpc.CallOption) (*ImportUtxosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportUtxosResponse)
	err := c.cc.Invoke(ctx, Wallet_ImportUtxos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetNetworkStatus(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NetworkStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkStatusResponse)
	err := c.cc.Invoke(ctx, Wallet_GetNetworkStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetConnectedHttpPeer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetConnectedHttpPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConnectedHttpPeerResponse)
	err := c.cc.Invoke(ctx, Wallet_GetConnectedHttpPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CancelTransaction(ctx context.Context, in *CancelTransactionRequest, opts ...grpc.CallOption) (*CancelTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelTransactionResponse)
	err := c.cc.Invoke(ctx, Wallet_CancelTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) RevalidateAllTransactions(ctx context.Context, in *RevalidateRequest, opts ...grpc.CallOption) (*RevalidateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevalidateResponse)
	err := c.cc.Invoke(ctx, Wallet_RevalidateAllTransactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ValidateAllTransactions(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateResponse)
	err := c.cc.Invoke(ctx, Wallet_ValidateAllTransactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) SendShaAtomicSwapTransaction(ctx context.Context, in *SendShaAtomicSwapRequest, opts ...grpc.CallOption) (*SendShaAtomicSwapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendShaAtomicSwapResponse)
	err := c.cc.Invoke(ctx, Wallet_SendShaAtomicSwapTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CreateBurnTransaction(ctx context.Context, in *CreateBurnTransactionRequest, opts ...grpc.CallOption) (*CreateBurnTransactionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateBurnTransactionResponse)
	err := c.cc.Invoke(ctx, Wallet_CreateBurnTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ClaimShaAtomicSwapTransaction(ctx context.Context, in *ClaimShaAtomicSwapRequest, opts ...grpc.CallOption) (*ClaimShaAtomicSwapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClaimShaAtomicSwapResponse)
	err := c.cc.Invoke(ctx, Wallet_ClaimShaAtomicSwapTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ClaimHtlcRefundTransaction(ctx context.Context, in *ClaimHtlcRefundRequest, opts ...grpc.CallOption) (*ClaimHtlcRefundResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClaimHtlcRefundResponse)
	err := c.cc.Invoke(ctx, Wallet_ClaimHtlcRefundTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) CreateTemplateRegistration(ctx context.Context, in *CreateTemplateRegistrationRequest, opts ...grpc.CallOption) (*CreateTemplateRegistrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTemplateRegistrationResponse)
	err := c.cc.Invoke(ctx, Wallet_CreateTemplateRegistration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) SignMessage(ctx context.Context, in *SignMessageRequest, opts ...grpc.CallOption) (*SignMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignMessageResponse)
	err := c.cc.Invoke(ctx, Wallet_SignMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) StreamTransactionEvents(ctx context.Context, in *TransactionEventRequest, opts ...grpc.CallOption) (Wallet_StreamTransactionEventsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Wallet_ServiceDesc.Streams[1], Wallet_StreamTransactionEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &walletStreamTransactionEventsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Wallet_StreamTransactionEventsClient interface {
	Recv() (*TransactionEventResponse, error)
	grpc.ClientStream
}

type walletStreamTransactionEventsClient struct {
	grpc.ClientStream
}

func (x *walletStreamTransactionEventsClient) Recv() (*TransactionEventResponse, error) {
	m := new(TransactionEventResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *walletClient) ImportTransactions(ctx context.Context, in *ImportTransactionsRequest, opts ...grpc.CallOption) (*ImportTransactionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportTransactionsResponse)
	err := c.cc.Invoke(ctx, Wallet_ImportTransactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *walletClient) GetAllCompletedTransactions(ctx context.Context, in *GetAllCompletedTransactionsRequest, opts ...grpc.CallOption) (*GetAllCompletedTransactionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllCompletedTransactionsResponse)
	err := c.cc.Invoke(ctx, Wallet_GetAllCompletedTransactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetAllCompletedTransactionsStream(ctx context.Context, in *GetAllCompletedTransactionsRequest, opts ...grpc.CallOption) (Wallet_GetAllCompletedTransactionsStreamClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Wallet_ServiceDesc.Streams[2], Wallet_GetAllCompletedTransactionsStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &walletGetAllCompletedTransactionsStreamClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Wallet_GetAllCompletedTransactionsStreamClient interface {
	Recv() (*GetCompletedTransactionsResponse, error)
	grpc.ClientStream
}

type walletGetAllCompletedTransactionsStreamClient struct {
	grpc.ClientStream
}

func (x *walletGetAllCompletedTransactionsStreamClient) Recv() (*GetCompletedTransactionsResponse, error) {
	m := new(GetCompletedTransactionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *walletClient) GetPaymentByReference(ctx context.Context, in *GetPaymentByReferenceRequest, opts ...grpc.CallOption) (*GetPaymentByReferenceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPaymentByReferenceResponse)
	err := c.cc.Invoke(ctx, Wallet_GetPaymentByReference_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetFeeEstimate(ctx context.Context, in *GetFeeEstimateRequest, opts ...grpc.CallOption) (*GetFeeEstimateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFeeEstimateResponse)
	err := c.cc.Invoke(ctx, Wallet_GetFeeEstimate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) GetFeePerGramStats(ctx context.Context, in *GetFeePerGramStatsRequest, opts ...grpc.CallOption) (*GetFeePerGramStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFeePerGramStatsResponse)
	err := c.cc.Invoke(ctx, Wallet_GetFeePerGramStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) ReplaceByFee(ctx context.Context, in *ReplaceByFeeRequest, opts ...grpc.CallOption) (*ReplaceByFeeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplaceByFeeResponse)
	err := c.cc.Invoke(ctx, Wallet_ReplaceByFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) UserPayForFee(ctx context.Context, in *UserPayForFeeRequest, opts ...grpc.CallOption) (*UserPayForFeeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserPayForFeeResponse)
	err := c.cc.Invoke(ctx, Wallet_UserPayForFee_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) RegisterValidatorNode(ctx context.Context, in *RegisterValidatorNodeRequest, opts ...grpc.CallOption) (*RegisterValidatorNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterValidatorNodeResponse)
	err := c.cc.Invoke(ctx, Wallet_RegisterValidatorNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) SubmitValidatorEvictionProof(ctx context.Context, in *SubmitValidatorEvictionProofRequest, opts ...grpc.CallOption) (*SubmitValidatorEvictionProofResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitValidatorEvictionProofResponse)
	err := c.cc.Invoke(ctx, Wallet_SubmitValidatorEvictionProof_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *walletClient) SubmitValidatorNodeExit(ctx context.Context, in *SubmitValidatorNodeExitRequest, opts ...grpc.CallOption) (*SubmitValidatorNodeExitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitValidatorNodeExitResponse)
	err := c.cc.Invoke(ctx, Wallet_SubmitValidatorNodeExit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WalletServer is the server API for Wallet service.
// All implementations must embed UnimplementedWalletServer
// for forward compatibility
type WalletServer interface {
	GetVersion(context.Context, *GetVersionRequest) (*GetVersionResponse, error)
	// Returns the current operational state of the wallet.
	//
	// This RPC provides an overview of the wallet's internal status, including:
	// - The latest blockchain height scanned by the wallet
	// - The current balance (available, pending incoming/outgoing)
	// - Network connectivity status with the base node
	//
	// This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
	// synchronized, and connected to the Tari network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.getState({});
	// console.log(response.scanned_height); // e.g., 1523493
	// console.log(response.balance.available_balance); // e.g., 1234567890
	// console.log(response.network.status); // e.g., "Online"
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "scanned_height": 1523493,
	//	  "balance": {
	//	    "available_balance": 1234567890,
	//	    "pending_incoming_balance": 100000000,
	//	    "pending_outgoing_balance": 0
	//	  },
	//	  "network": {
	//	    "status": "Online",
	//	    "avg_latency_ms": 28,
	//	    "num_node_connections": 8
	//	  }
	//	}
	//
	// ```
	GetState(context.Context, *GetStateRequest) (*GetStateResponse, error)
	// This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
	//
	// Example usage (JavaScript):
	// ```javascript
	// const response = await client.checkConnectivity({});
	// console.log(response.status); // e.g., 1 (Online)
	// ```
	//
	// Example response:
	// ```json
	//
	//	{
	//	  "status": "Online"
	//	}
	//
	// ```
	CheckConnectivity(context.Context, *GetConnectivityRequest) (*CheckConnectivityResponse, error)
	// Check for new updates
	CheckForUpdates(context.Context, *Empty) (*SoftwareUpdate, error)
	// The `Identify` RPC call returns the identity information of the wallet node.
	// This includes:
	// - **Public Key**: The wallet's cryptographic public key.
	// - **Public Address**: This will always be empty as the wallet has no contactable public comms address.
	// - **Node ID**: The unique identifier of the wallet node in the network.
	//
	// Example usage (JavaScript):
	// ```javascript
	// // Call the Identify RPC method
	//
	//	client.Identify({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Identity Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	  "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
	//	  "public_address": "",
	//	  "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
	//	}
	//
	// ```
	Identify(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error)
	// This RPC returns two types of wallet addresses: interactive and one-sided addresses.
	// It provides these addresses in byte format as part of the response.
	// - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
	// - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
	//
	// Example usage (JavaScript):
	// // Call the GetAddress RPC method
	//
	//	client.GetAddress({}, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	//	// ```json
	//
	//	{
	//	  "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
	//	  "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
	//	}
	//
	// ```
	GetAddress(context.Context, *Empty) (*GetAddressResponse, error)
	// This RPC returns addresses generated for a specific payment ID. It provides both the interactive
	// and one-sided addresses for the given payment ID, along with their respective representations in
	// base58 and emoji formats.
	//
	// Example usage (JavaScript):
	//
	// ```javascript
	// // Prepare the payment ID for the request
	// const paymentId = Buffer.from('your_payment_id_here', 'hex');
	// const request = { payment_id: paymentId };
	//
	// // Call the GetPaymentIdAddress RPC method
	//
	//	client.GetPaymentIdAddress(request, (error, response) => {
	//	  if (error) {
	//	    console.error('Error:', error);
	//	  } else {
	//	    console.log('Payment ID Address Response:', response);
	//	  }
	//	});
	//
	// ```
	//
	// **Sample JSON Response:**
	//
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "ðŸ¢ðŸŒŠðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸž.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­",
	//	 "one_sided_address_emoji": "ðŸ¢ðŸ“ŸðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸžðŸ“œ.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­"
	//	}
	//
	// ```
	GetPaymentIdAddress(context.Context, *GetPaymentIdAddressRequest) (*GetCompleteAddressResponse, error)
	// This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
	// The response includes:
	// - Raw binary
	// - Base58-encoded (human-readable)
	// - Emoji-encoded (for fun and friendliness)
	//
	// Example usage (JavaScript with gRPC):
	//
	// ```js
	// const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
	//
	//	client.getCompleteAddress({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// Sample response:
	// ```json
	//
	//	{
	//	 "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
	//	 "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
	//	 "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
	//	 "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
	//	 "interactive_address_emoji": "ðŸ¢ðŸŒŠðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸž.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­",
	//	 "one_sided_address_emoji": "ðŸ¢ðŸ“ŸðŸ’¤ðŸ”ŒðŸš‘ðŸ›ðŸ¦âš½ðŸ“ðŸ­ðŸšðŸŽ¢ðŸ”ªðŸ¥ðŸ‘›ðŸžðŸ“œ.....ðŸðŸŸðŸ’µðŸŽ‰ðŸ¯ðŸŽðŸŽ¾ðŸŽ¼ðŸ’»ðŸ’„ðŸ³ðŸðŸ¤”ðŸ¥ðŸ«ðŸ‘…ðŸš€ðŸ¬ðŸŽ­"
	//	}
	//
	// ```
	GetCompleteAddress(context.Context, *Empty) (*GetCompleteAddressResponse, error)
	PrepareOneSidedTransactionForSigning(context.Context, *PrepareOneSidedTransactionForSigningRequest) (*PrepareOneSidedTransactionForSigningResponse, error)
	BroadcastSignedOneSidedTransaction(context.Context, *BroadcastSignedOneSidedTransactionRequest) (*BroadcastSignedOneSidedTransactionResponse, error)
	// This call supports standard interactive transactions (Mimblewimble),
	// one-sided transactions, and one-sided-to-stealth-address transactions.
	// Each recipient must include a valid Tari address, amount, fee, and payment type.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const recipient = new PaymentRecipient();
	// recipient.setAddress("14HVCEeZ...");
	// recipient.setAmount(1000000); // 1 T
	// recipient.setFeePerGram(25);
	// recipient.setPaymentType(PaymentType.ONE_SIDED);
	// recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
	//
	// const request = new TransferRequest();
	// request.setRecipientsList([recipient]);
	//
	//	client.transfer(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.toObject());
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "results": [
	//	    {
	//	      "address": "14HVCEeZ...",
	//	      "transaction_id": 12345,
	//	      "is_success": true,
	//	      "failure_message": ""
	//	    }
	//	  ]
	//	}
	Transfer(context.Context, *TransferRequest) (*TransferResponse, error)
	// Returns the transaction details for the given transaction IDs.
	//
	// The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
	// The response includes details such as transaction status, direction, amount, fee, and more.
	//
	// ### Request Parameters:
	//
	// - `transaction_ids` (required):
	//   - **Type**: `repeated uint64`
	//   - **Description**: A list of transaction IDs to query.
	//   - **Restrictions**:
	//   - Must contain at least one ID.
	//   - All IDs must be valid unsigned 64-bit integers.
	//   - Duplicates will be ignored; only the first occurrence is processed.
	//   - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { transaction_ids: [12345, 67890] };
	//
	//	client.getTransactionInfo(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.transactions);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_OUTBOUND",
	//	      "amount": 1000000,
	//	      "fee": 25,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	GetTransactionInfo(context.Context, *GetTransactionInfoRequest) (*GetTransactionInfoResponse, error)
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-001"
	//	  }
	//	};
	//
	// const call = client.getCompletedTransactions(request);
	//
	//	call.on('data', (response) => {
	//	  console.log(response.transaction);
	//	});
	//
	// call.on('error', console.error);
	// call.on('end', () => console.log("Stream ended"));
	// ```
	//
	// ### Sample Streamed JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 12345,
	//	    "source_address": "0x1234abcd...",
	//	    "dest_address": "0x5678efgh...",
	//	    "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	    "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	    "amount": 500000,
	//	    "fee": 20,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0xabcdef...",
	//	    "timestamp": 1681234567,
	//	    "payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 1523493
	//	  }
	//	}
	//
	// ```
	GetCompletedTransactions(*GetCompletedTransactionsRequest, Wallet_GetCompletedTransactionsServer) error
	// Returns all transactions that were mined at a specific block height.
	//
	// The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
	// at the specified block height. The response includes all transactions in a single response,
	// with each transaction including details such as status, direction, amount,
	// fees, and associated metadata.
	//
	// ### Request Parameters:
	//
	// - `block_height` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The specific block height to fetch transactions for.
	//   - **Restrictions**:
	//   - Must be a valid block height (greater than 0).
	//   - If the block height is beyond the current chain height, no transactions will be returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  block_height: 1523493
	//	};
	//
	// const response = await client.getBlockHeightTransactions(request);
	// console.log(response.transactions);
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transactions": [
	//	    {
	//	      "tx_id": 12345,
	//	      "source_address": "0x1234abcd...",
	//	      "dest_address": "0x5678efgh...",
	//	      "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	      "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	      "amount": 500000,
	//	      "fee": 20,
	//	      "is_cancelled": false,
	//	      "excess_sig": "0xabcdef...",
	//	      "timestamp": 1681234567,
	//	      "payment_id": "0xdeadbeef...",
	//	      "mined_in_block_height": 1523493
	//	    }
	//	  ]
	//	}
	//
	// ```
	GetBlockHeightTransactions(context.Context, *GetBlockHeightTransactionsRequest) (*GetBlockHeightTransactionsResponse, error)
	// Returns all PayRefs (payment references) for a specific transaction.
	//
	// The `GetTransactionPayRefs` call retrieves all PayRefs associated with the specified
	// transaction ID. PayRefs are cryptographic references generated from output hashes
	// that allow recipients to verify payments without revealing sensitive transaction details.
	//
	// ### Request Parameters:
	//
	// - `transaction_id` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The transaction ID to retrieve PayRefs for.
	//   - **Restrictions**:
	//   - Must be a valid transaction ID that exists in the wallet.
	//   - If the transaction ID is invalid or not found, an error will be returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  transaction_id: 12345
	//	};
	//
	// const response = await client.getTransactionPayRefs(request);
	// console.log("PayRefs:", response.payment_references.map(ref => Buffer.from(ref).toString('hex')));
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "payment_references": [
	//	    "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
	//	    "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
	//	  ]
	//	}
	//
	// ```
	GetTransactionPayRefs(context.Context, *GetTransactionPayRefsRequest) (*GetTransactionPayRefsResponse, error)
	// Returns the wallet balance details.
	//
	// The `GetBalance` call retrieves the current balance status of the wallet,
	// optionally filtered by a specific `payment_id`. The response includes detailed
	// breakdowns of available, pending incoming/outgoing, and timelocked balances.
	//
	// ### Request Parameters:
	//
	// - `payment_id` (optional):
	//   - **Type**: `UserPaymentId` (one of several formats).
	//   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
	//   - **Accepted Formats** (must provide **only one**):
	//   - `u256`: a 32-byte hexadecimal identifier.
	//   - `utf8_string`: a human-readable string ID.
	//   - `user_bytes`: raw binary bytes.
	//   - **Restrictions**:
	//   - Only one format must be provided at a time.
	//   - If multiple or no formats are provided within `payment_id`, the request will return an error.
	//   - If `payment_id` is omitted, the total wallet balance is returned.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  payment_id: {
	//	    utf8_string: "invoice-002"
	//	  }
	//	};
	//
	//	client.getBalance(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Balance:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "available_balance": 950000,
	//	  "pending_incoming_balance": 200000,
	//	  "pending_outgoing_balance": 50000,
	//	  "timelocked_balance": 100000
	//	}
	//
	// ```
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	// Returns the total value of unspent outputs in the wallet.
	//
	// The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
	// currently held by the wallet. These are outputs that have not yet been spent or time-locked,
	// and are available for future transactions.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getUnspentAmounts({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Total unspent amount:", response.amount);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "amount": 1250000
	//	}
	//
	// ```
	GetUnspentAmounts(context.Context, *Empty) (*GetUnspentAmountsResponse, error)
	// Creates a transaction that splits funds into multiple smaller outputs.
	//
	// The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
	// This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
	// The resulting transaction is broadcast and can be tracked via its transaction ID.
	//
	// ### Request Parameters:
	//
	// - `amount_per_split` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The value of each individual output in the split.
	//   - **Restrictions**: Must be greater than zero.
	//
	// - `split_count` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The number of outputs to create.
	//   - **Restrictions**: Must be greater than zero and within practical system limits.
	//
	// - `fee_per_gram` (required):
	//   - **Type**: `uint64`
	//   - **Description**: The transaction fee rate (per gram of weight).
	//   - **Restrictions**: Should be set high enough to ensure confirmation.
	//
	// - `lock_height` (optional):
	//   - **Type**: `uint64`
	//   - **Description**: The earliest block height at which the transaction becomes valid.
	//   - **Restrictions**: Defaults to 0 if not specified.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: A user-defined identifier for tracking or referencing the transaction.
	//   - **Restrictions**: Optional; can be left empty.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  amount_per_split: 100000,
	//	  split_count: 5,
	//	  fee_per_gram: 25,
	//	  lock_height: 0,
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.coinSplit(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Created CoinSplit Tx ID:", response.tx_id);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_id": 987654321
	//	}
	//
	// ```
	CoinSplit(context.Context, *CoinSplitRequest) (*CoinSplitResponse, error)
	// Imports UTXOs into the wallet as spendable outputs.
	//
	// The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
	// into the wallet, marking them as spendable without needing rewindable metadata.
	// Each UTXO is associated with a transaction ID in the response.
	//
	// ### Request Parameters:
	//
	// - `outputs` (required):
	//   - **Type**: `repeated UnblindedOutput`
	//   - **Description**: A list of unblinded outputs to import into the wallet.
	//   - **Restrictions**:
	//   - Each output must be valid and convertible to an internal UTXO format.
	//   - The list must contain at least one item.
	//
	// - `payment_id` (optional):
	//   - **Type**: `bytes`
	//   - **Description**: An optional user-defined identifier to associate with the imported outputs.
	//   - **Restrictions**:
	//   - Can be left empty if not needed.
	//   - Must be a valid byte string if provided.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  outputs: [/* array of unblinded outputs */],
	//	  payment_id: new Uint8Array([])
	//	};
	//
	//	client.importUtxos(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Imported Tx IDs:", response.tx_ids);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "tx_ids": [101, 102, 103]
	//	}
	//
	// ```
	ImportUtxos(context.Context, *ImportUtxosRequest) (*ImportUtxosResponse, error)
	// Returns the wallet's current network connectivity status.
	//
	// The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
	// including whether it is online, the number of active peer connections, and the average latency
	// to the configured base node.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.getNetworkStatus({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Network Status:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "status": "ONLINE",
	//	  "avg_latency_ms": 142,
	//	  "num_node_connections": 1
	//	}
	//
	// ```
	//
	// ### Status Field Values:
	//
	// The `status` field indicates the current network connectivity of the wallet. Possible values are:
	//
	// - `INITIALIZING`:
	//   - The wallet connectivity is busy initializing.
	//
	// - `ONLINE`:
	//   - The wallet is fully connected to the network and functioning normally.
	//
	// - `DEGRADED`:
	//   - The wallet is connected but has high latency.
	//   - This could indicate issues with network connectivity, such as as a congested network, leading to reduced
	//     performance or reliability.
	//
	// - `OFFLINE`:
	//   - The wallet is not connected to any peers.
	//   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
	GetNetworkStatus(context.Context, *Empty) (*NetworkStatusResponse, error)
	// Returns a list of HTTP peers currently connected to the wallet.
	//
	// The `GetConnectedHttpPeer` call retrieves information about the HTTP peer that the wallet is currently
	// connected to. The response is a `GetConnectedHttpPeerResponse` containing a list of `HttpPeer` objects.
	//
	// ### Request Parameters:
	//
	// - *(none)*
	//   - This method uses an empty request body (`google.protobuf.Empty`).
	//   - No filters or arguments are required.
	//
	// ### Response Fields:
	//
	// - **connected_peers**: List of `HttpPeer` objects currently connected to the wallet.
	//   - **url**: The connection URL (string).
	//   - **last_latency**: The latency of the last request to this peer (`AverageLatency`).
	//   - **is_online**: Online status of the peer (bool).
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	client.GetConnectedHttpPeer({}, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Connected Peers:", response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "connected_peers": {
	//	      "url": "http://127.0.0.1:18080",
	//	      "last_latency": { "value": 42 },
	//	      "is_online": true
	//	   }
	//	}
	//
	// ```
	GetConnectedHttpPeer(context.Context, *Empty) (*GetConnectedHttpPeerResponse, error)
	// Cancels a specific transaction by its ID.
	//
	// The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
	// If the cancellation is successful, the response will indicate success. Otherwise, the response will
	// contain a failure message with the reason for the failure.
	//
	// ### Request Parameters:
	//
	// - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
	//
	// ### Response Fields:
	//
	// - **is_success**: A boolean indicating whether the cancellation was successful (bool).
	//   - `true` if the cancellation was successful, `false` if not.
	//
	// - **failure_message**: A string that provides the reason for the failure, if applicable (string).
	//   - This field will be empty if the cancellation was successful.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const request = { tx_id: 12345 };
	//
	//	client.cancelTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	//
	// ```
	CancelTransaction(context.Context, *CancelTransactionRequest) (*CancelTransactionResponse, error)
	// Will trigger a complete revalidation of all wallet outputs.
	RevalidateAllTransactions(context.Context, *RevalidateRequest) (*RevalidateResponse, error)
	// Will trigger a validation of all wallet outputs.
	ValidateAllTransactions(context.Context, *ValidateRequest) (*ValidateResponse, error)
	// Sends a XTR SHA Atomic Swap transaction.
	//
	// The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
	// transaction using SHA. It allows the sender to send a payment to the recipient
	// in exchange for an atomic swap, with SHA used as the secret for the swap.
	// The method accepts the recipient's information and initiates the transaction.
	//
	// ### Request Parameters:
	//   - **recipient** (required): A PaymentRecipient object containing the recipient's address,
	//     the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the transaction.
	// - **pre_image**: The SHA pre-image of the atomic swap.
	// - **output_hash**: The hash of the output associated with the transaction.
	// - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
	// - **failure_message**: Provides an error message if the transaction failed.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  recipient: {
	//	    address: "t1abc12345",
	//	    amount: 1000000,
	//	    fee_per_gram: 10,
	//	    payment_id: "0xdeadbeef"
	//	  }
	//	};
	//
	//	client.sendShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "pre_image": "0xabcdef1234567890",
	//	  "output_hash": "0x123456abcdef7890",
	//	  "is_success": true,
	//	  "failure_message": ""
	//	}
	SendShaAtomicSwapTransaction(context.Context, *SendShaAtomicSwapRequest) (*SendShaAtomicSwapResponse, error)
	// Creates a burn transaction for burning a specified amount of Tari currency.
	//
	// The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
	// by initiating a burn transaction. It allows the user to specify the amount to burn,
	// along with a fee per gram and optionally a payment ID and claim public key.
	//
	// ### Request Parameters:
	// - **amount** (required): The amount of Tari to be burned.
	// - **fee_per_gram** (required): The fee per gram for the transaction.
	// - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
	// - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
	//
	// ### Response Fields:
	// - **transaction_id**: The ID of the burn transaction.
	// - **is_success**: Indicates whether the burn transaction was successfully created.
	// - **failure_message**: Provides an error message if the transaction creation failed.
	// - **commitment**: The commitment associated with the burn transaction.
	// - **ownership_proof**: A proof of ownership for the burned coins.
	// - **range_proof**: The range proof associated with the burned coins.
	// - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  amount: 1000000,
	//	  fee_per_gram: 10,
	//	  claim_public_key: "0xabcdef1234567890",
	//	  payment_id: "0xdeadbeef"
	//	};
	//
	//	client.createBurnTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 123456789,
	//	  "is_success": true,
	//	  "failure_message": "",
	//	  "commitment": "0xcommitmenthash",
	//	  "ownership_proof": "0xownershipproof",
	//	  "range_proof": "0xrangeproof",
	//	  "reciprocal_claim_public_key": "0xreciprocalpublickey"
	//	}
	CreateBurnTransaction(context.Context, *CreateBurnTransactionRequest) (*CreateBurnTransactionResponse, error)
	// Claims a SHA Atomic Swap transaction using a pre-image and output hash.
	//
	// The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
	// a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
	// previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
	// secret required to spend the output.
	//
	// ### Request Parameters:
	// - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
	// - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
	// - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
	//
	// ### Input Validation:
	// - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
	// - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
	// - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
	//	  pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
	//	  fee_per_gram: 10
	//	};
	//
	//	client.claimShaAtomicSwapTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 789654,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimShaAtomicSwapTransaction(context.Context, *ClaimShaAtomicSwapRequest) (*ClaimShaAtomicSwapResponse, error)
	// Claims an HTLC refund transaction after the timelock period has passed.
	//
	// The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
	// to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
	// This is possible only after the output's timelock has expired.
	//
	// ### Request Parameters:
	// - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
	// - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
	//
	// ### Input Validation:
	// - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
	// - `fee_per_gram` must be a non-zero `uint64` value.
	//
	// ### Response Fields:
	// - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  output_hash: "aabbccddeeff0011...99",
	//	  fee_per_gram: 20
	//	};
	//
	//	client.claimHtlcRefundTransaction(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log(response.results);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": {
	//	    "address": "",
	//	    "transaction_id": 889977,
	//	    "is_success": true,
	//	    "failure_message": ""
	//	  }
	//	}
	ClaimHtlcRefundTransaction(context.Context, *ClaimHtlcRefundRequest) (*ClaimHtlcRefundResponse, error)
	// Creates a transaction with a template registration output
	CreateTemplateRegistration(context.Context, *CreateTemplateRegistrationRequest) (*CreateTemplateRegistrationResponse, error)
	// Signs a message using the wallet's node identity private key.
	//
	// The `SignMessage` call creates a Schnorr signature over a message using the wallet's node identity private key.
	// This signature can be used to prove ownership of the wallet or authenticate messages.
	// The signature is returned as separate components (signature and public nonce) for verification.
	//
	// ### Request Parameters:
	//
	// - `message` (required):
	//   - **Type**: `bytes`
	//   - **Description**: The message to be signed (arbitrary bytes).
	//   - **Restrictions**: Can be any byte sequence.
	//
	// ### Response Fields:
	//
	// - **signature**: The Schnorr signature as hex-encoded bytes.
	// - **public_nonce**: The public nonce component of the signature as hex-encoded bytes.
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	//
	//	const request = {
	//	  message: Buffer.from("Hello Tari!", "utf-8")
	//	};
	//
	//	client.signMessage(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Signature:", response.signature, "Nonce:", response.public_nonce);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "signature": "a1b2c3d4e5f6...",
	//	  "public_nonce": "f6e5d4c3b2a1..."
	//	}
	//
	// ```
	//
	// ### Security Notes:
	//
	// - This signs with the wallet's node identity private key.
	// - The signature can be verified using the wallet's public key.
	// - Use this for authentication and ownership proofs only.
	SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error)
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	// const call = client.streamTransactionEvents({});
	//
	//	call.on("data", (response) => {
	//	  console.log("Transaction Event:", response.transaction);
	//	});
	//
	//	call.on("end", () => {
	//	  console.log("Stream ended.");
	//	});
	//
	//	call.on("error", (err) => {
	//	  console.error("Stream error:", err);
	//	});
	//
	// ```
	//
	// ### Sample JSON Streamed Response:
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "event": "Mined",
	//	    "tx_id": "103248",
	//	    "source_address": "0xabc123...",
	//	    "dest_address": "0xdef456...",
	//	    "status": "Completed",
	//	    "direction": "Outbound",
	//	    "amount": 100000000,
	//	    "payment_id": "0xdeadbeef..."
	//	  }
	//	}
	//
	// ```
	StreamTransactionEvents(*TransactionEventRequest, Wallet_StreamTransactionEventsServer) error
	ImportTransactions(context.Context, *ImportTransactionsRequest) (*ImportTransactionsResponse, error)
	// Deprecated: Do not use.
	// Get all completed transactions including cancelled ones, sorted by timestamp and paginated
	// DEPRECATED: Use GetAllCompletedTransactionsStream for better performance and memory efficiency
	GetAllCompletedTransactions(context.Context, *GetAllCompletedTransactionsRequest) (*GetAllCompletedTransactionsResponse, error)
	// Streams previously completed wallet transactions to the client.
	//
	// The `GetAllCompletedTransactionsStream` RPC provides a paginated, filtered stream of previously completed transactions
	// from the wallet database. Unlike real-time event streaming, this RPC allows clients to retrieve historical transaction
	// data using offset, limit, and optional status-based filtering.
	//
	// This is ideal for applications that need to display a transaction history, perform analytics, or resume from a known offset.
	//
	// ### Request Parameters:
	// - **offset** (uint64): The starting index in the list of completed transactions.
	// - **limit** (uint64): Maximum number of transactions to return. Capped at 50 per request.
	// - **status_bitflag** (uint64): Optional bitflag to filter transactions by status (e.g., mined, cancelled).
	//
	// ### Response Stream:
	// - Each message in the response stream is a `GetCompletedTransactionsResponse` containing:
	//   - **transaction**: A `TransactionInfo` object representing a completed wallet transaction.
	//
	// ### `TransactionInfo` Fields:
	// - **tx_id** (uint64): Unique transaction identifier.
	// - **source_address** (bytes): Sender address.
	// - **dest_address** (bytes): Recipient address.
	// - **status** (enum): Status of the transaction (`Completed`, `Mined`, `Cancelled`, etc.).
	// - **direction** (enum): `"Inbound"` or `"Outbound"`.
	// - **amount** (uint64): Transaction amount in microTari.
	// - **fee** (uint64): Transaction fee in microTari.
	// - **is_cancelled** (bool): Whether the transaction was cancelled.
	// - **excess_sig** (bytes): Signature of the transaction kernel excess.
	// - **timestamp** (uint64): UNIX timestamp of the transaction creation time.
	// - **raw_payment_id** (bytes): Raw payment ID used in the transaction.
	// - **user_payment_id** (bytes): User-visible payment ID, if applicable.
	// - **mined_in_block_height** (uint64): Block height where the transaction was mined. Zero if not mined.
	// - **input_commitments** (repeated bytes): Commitments for transaction inputs.
	// - **output_commitments** (repeated bytes): Commitments for transaction outputs.
	// - **payment_references_sent** (repeated bytes): Metadata references associated with sent outputs.
	// - **payment_references_received** (repeated bytes): Metadata references associated with received outputs.
	// - **payment_references_change** (repeated bytes): Metadata references associated with change outputs.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const call = client.getAllCompletedTransactionsStream({
	//	  offset: 0,
	//	  limit: 20,
	//	  status_bitflag: 0
	//	});
	//
	//	call.on("data", (response) => {
	//	  console.log("Completed Transaction:", response.transaction);
	//	});
	//
	//	call.on("end", () => {
	//	  console.log("Stream ended.");
	//	});
	//
	//	call.on("error", (err) => {
	//	  console.error("Stream error:", err);
	//	});
	//
	// ```
	//
	// ### Sample JSON Streamed Response:
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 103248,
	//	    "source_address": "0xabc123...",
	//	    "dest_address": "0xdef456...",
	//	    "status": "Completed",
	//	    "direction": "Outbound",
	//	    "amount": 100000000,
	//	    "fee": 200000,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0x...",
	//	    "timestamp": 1670000000,
	//	    "raw_payment_id": "0xdeadbeef...",
	//	    "user_payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 202000,
	//	    "input_commitments": ["0x...", "0x..."],
	//	    "output_commitments": ["0x...", "0x..."],
	//	    "payment_references_sent": ["0x...", "0x..."],
	//	    "payment_references_received": [],
	//	    "payment_references_change": []
	//	  }
	//	}
	//
	// ```
	GetAllCompletedTransactionsStream(*GetAllCompletedTransactionsRequest, Wallet_GetAllCompletedTransactionsStreamServer) error
	// Gets transaction information by payment reference (PayRef)
	//
	// The `GetPaymentByReference` call retrieves transaction information using a 32-byte payment reference hash.
	// PayRefs are generated as Blake2b_256(block_hash || output_hash) and provide a stable way to look up
	// transactions even after outputs are spent.
	//
	// ### Request Parameters:
	//
	// - `payment_reference` (required):
	//   - **Type**: `bytes` (32 bytes)
	//   - **Description**: The payment reference hash to look up
	//   - **Restrictions**: Must be exactly 32 bytes representing a valid PayRef
	//
	// ### Example JavaScript gRPC client usage:
	//
	// ```javascript
	// const payref = Buffer.from('a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890', 'hex');
	// const request = { payment_reference: payref };
	//
	//	client.getPaymentByReference(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log('Transaction found:', response.transaction);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	//
	// ```json
	//
	//	{
	//	  "transaction": {
	//	    "tx_id": 12345,
	//	    "source_address": "0x1234abcd...",
	//	    "dest_address": "0x5678efgh...",
	//	    "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
	//	    "direction": "TRANSACTION_DIRECTION_INBOUND",
	//	    "amount": 1000000,
	//	    "fee": 20,
	//	    "is_cancelled": false,
	//	    "excess_sig": "0xabcdef...",
	//	    "timestamp": 1681234567,
	//	    "payment_id": "0xdeadbeef...",
	//	    "mined_in_block_height": 150000
	//	  }
	//	}
	//
	// ```
	GetPaymentByReference(context.Context, *GetPaymentByReferenceRequest) (*GetPaymentByReferenceResponse, error)
	// Estimates the transaction fee based on amount, fee rate, and number of outputs.
	//
	// The `GetFeeEstimate` call allows clients to calculate the expected transaction fee before sending funds.
	// This is useful for presenting fee information to the user or for ensuring sufficient funds are available.
	//
	// ### Request Parameters:
	// - **amount** (required): The amount to send, in microTari. (1 Tari = 1,000,000 ÂµT).
	// - **fee_per_gram** (required): The fee per gram (weight unit) to use for the estimate. Higher values may improve priority.
	// - **output_count** (required): The number of outputs to create in the transaction (e.g., 2 = recipient + change).
	//
	// ### Input Validation:
	// - `amount` must be a non-zero `uint64` representing the amount to transfer.
	// - `fee_per_gram` must be a non-zero `uint64`; zero or low fees may result in delayed confirmation or failure.
	// - `output_count` must be convertible to a valid `usize`; large values may increase the fee significantly.
	//
	// ### Response Fields:
	// - **estimated_fee**: A `uint64` value representing the estimated total transaction fee in microTari.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  amount: 1000000,         // Sending 1 Tari
	//	  fee_per_gram: 5,         // Fee rate of 5 ÂµT/g
	//	  output_count: 2          // One recipient + one change output
	//	};
	//
	//	client.getFeeEstimate(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else console.log("Estimated fee:", response.estimated_fee);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "estimated_fee": 12345
	//	}
	//
	// ```
	GetFeeEstimate(context.Context, *GetFeeEstimateRequest) (*GetFeeEstimateResponse, error)
	// Retrieves fee-per-gram statistics over recent blocks.
	//
	// The `GetFeePerGramStats` call returns aggregated fee rate information to help clients
	// understand recent network fee trends. This can be used for setting appropriate fees
	// when constructing transactions.
	//
	// ### Request Parameters:
	//   - **block_count** (optional): The number of recent blocks to include in the statistics.
	//     If not specified or zero, a default number of blocks will be used.
	//
	// ### Input Validation:
	// - `block_count` must be a non-negative `uint64`. Large values may increase query time.
	//
	// ### Response Fields:
	// - **fee_per_gram_stats**: A list of `FeePerGramStat` objects summarizing fee data over the specified blocks.
	//
	// Each `FeePerGramStat` contains:
	// - **average_fee_per_gram**: Average fee per gram observed over the blocks.
	// - **min_fee_per_gram**: Minimum fee per gram observed.
	// - **max_fee_per_gram**: Maximum fee per gram observed.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  block_count: 10 // Consider fees over the last 10 blocks
	//	};
	//
	//	client.getFeePerGramStats(request, (err, response) => {
	//	  if (err) console.error(err);
	//	  else response.fee_per_gram_stats.forEach(stat => {
	//	    console.log(`Avg: ${stat.average_fee_per_gram}, Min: ${stat.min_fee_per_gram}, Max: ${stat.max_fee_per_gram}`);
	//	  });
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "fee_per_gram_stats": [
	//	    {
	//	      "average_fee_per_gram": 5,
	//	      "min_fee_per_gram": 3,
	//	      "max_fee_per_gram": 10
	//	    }
	//	  ]
	//	}
	//
	// ```
	GetFeePerGramStats(context.Context, *GetFeePerGramStatsRequest) (*GetFeePerGramStatsResponse, error)
	// Attempts to replace an existing transaction with a new one that has a higher fee.
	//
	// The `ReplaceByFee` call enables clients to increase the fee of a pending transaction,
	// potentially speeding up its confirmation by incentivizing miners to prioritize it.
	//
	// ### Request Parameters:
	//   - **transaction_id** (required): The ID of the original transaction to replace.
	//   - **fee_increase** (required): The additional fee amount to add, specified in microTari.
	//     Must be greater than zero.
	//
	// ### Input Validation:
	// - `transaction_id` must correspond to a currently unconfirmed transaction.
	// - `fee_increase` must be a non-zero `uint64`. Zero or negative values are invalid.
	//
	// ### Response Fields:
	// - **transaction_id**: The transaction ID of the new replacement transaction.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  transaction_id: 123456,
	//	  fee_increase: 5000  // Increase fee by 5,000 microTari
	//	};
	//
	//	client.replaceByFee(request, (err, response) => {
	//	  if (err) console.error("Failed to replace by fee:", err);
	//	  else console.log("Replacement transaction ID:", response.transaction_id);
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "transaction_id": 7891011
	//	}
	//
	// ```
	ReplaceByFee(context.Context, *ReplaceByFeeRequest) (*ReplaceByFeeResponse, error)
	// Allows users to pay a specified fee for spending transaction outputs to given recipients.
	//
	// The `UserPayForFee` call enables clients to request that the wallet pays the fee
	// for one or more transactions identified by their IDs, sending funds to the specified recipients.
	// This is useful for fee bumping or covering transaction fees on behalf of recipients.
	//
	// ### Request Parameters:
	// - **recipients** (required): A list of transfers, each specifying:
	//   - `tx_id`: The transaction ID whose outputs will be spent.
	//   - `fee`: The fee amount in microTari to pay for this transfer.
	//   - `destination`: The Base58-encoded Tari address of the recipient.
	//
	// ### Input Validation:
	// - Each `tx_id` must correspond to a valid transaction whose outputs can be spent.
	// - Each `fee` must be a non-negative uint64 specifying the fee to pay.
	// - Each `destination` must be a valid Base58 Tari address.
	//
	// ### Response Fields:
	// - **results**: A list of `TransferResult` objects, one per requested recipient, each containing:
	//   - `address`: The recipient address as a string.
	//   - `transaction_id`: The ID of the newly created transaction (or zero if failed).
	//   - `is_success`: Boolean indicating if the fee payment transaction succeeded.
	//   - `failure_message`: A string describing the error if the transaction failed.
	//   - `transaction_info`: Detailed transaction metadata if available.
	//
	// ### Example JavaScript gRPC client usage:
	// ```javascript
	//
	//	const request = {
	//	  recipients: [
	//	    {
	//	      tx_id: 123,
	//	      fee: 1000,
	//	      destination: "tari1qxyz..."
	//	    },
	//	    {
	//	      tx_id: 456,
	//	      fee: 2000,
	//	      destination: "tari1qabcd..."
	//	    }
	//	  ]
	//	};
	//
	//	client.userPayForFee(request, (err, response) => {
	//	  if (err) console.error("Fee payment failed:", err);
	//	  else {
	//	    response.results.forEach(result => {
	//	      if (result.is_success) {
	//	        console.log(`Fee paid successfully to ${result.address} in tx ${result.transaction_id}`);
	//	      } else {
	//	        console.error(`Failed to pay fee for ${result.address}: ${result.failure_message}`);
	//	      }
	//	    });
	//	  }
	//	});
	//
	// ```
	//
	// ### Sample JSON Response:
	// ```json
	//
	//	{
	//	  "results": [
	//	    {
	//	      "address": "tari1qxyz...",
	//	      "transaction_id": 789,
	//	      "is_success": true,
	//	      "failure_message": "",
	//	      "transaction_info": {
	//	        "tx_id": 789,
	//	        "source_address": "...",
	//	        "dest_address": "...",
	//	        "status": "Completed",
	//	        "direction": "Outbound",
	//	        "amount": 50000,
	//	        "fee": 1000,
	//	        "is_cancelled": false,
	//	        "timestamp": 1620000000
	//	      }
	//	    },
	//	    {
	//	      "address": "tari1qabcd...",
	//	      "transaction_id": 0,
	//	      "is_success": false,
	//	      "failure_message": "Invalid destination address",
	//	      "transaction_info": null
	//	    }
	//	  ]
	//	}
	//
	// ```
	UserPayForFee(context.Context, *UserPayForFeeRequest) (*UserPayForFeeResponse, error)
	RegisterValidatorNode(context.Context, *RegisterValidatorNodeRequest) (*RegisterValidatorNodeResponse, error)
	SubmitValidatorEvictionProof(context.Context, *SubmitValidatorEvictionProofRequest) (*SubmitValidatorEvictionProofResponse, error)
	SubmitValidatorNodeExit(context.Context, *SubmitValidatorNodeExitRequest) (*SubmitValidatorNodeExitResponse, error)
	mustEmbedUnimplementedWalletServer()
}

// UnimplementedWalletServer must be embedded to have forward compatible implementations.
type UnimplementedWalletServer struct {
}

func (UnimplementedWalletServer) GetVersion(context.Context, *GetVersionRequest) (*GetVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedWalletServer) GetState(context.Context, *GetStateRequest) (*GetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetState not implemented")
}
func (UnimplementedWalletServer) CheckConnectivity(context.Context, *GetConnectivityRequest) (*CheckConnectivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckConnectivity not implemented")
}
func (UnimplementedWalletServer) CheckForUpdates(context.Context, *Empty) (*SoftwareUpdate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckForUpdates not implemented")
}
func (UnimplementedWalletServer) Identify(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Identify not implemented")
}
func (UnimplementedWalletServer) GetAddress(context.Context, *Empty) (*GetAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAddress not implemented")
}
func (UnimplementedWalletServer) GetPaymentIdAddress(context.Context, *GetPaymentIdAddressRequest) (*GetCompleteAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentIdAddress not implemented")
}
func (UnimplementedWalletServer) GetCompleteAddress(context.Context, *Empty) (*GetCompleteAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompleteAddress not implemented")
}
func (UnimplementedWalletServer) PrepareOneSidedTransactionForSigning(context.Context, *PrepareOneSidedTransactionForSigningRequest) (*PrepareOneSidedTransactionForSigningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareOneSidedTransactionForSigning not implemented")
}
func (UnimplementedWalletServer) BroadcastSignedOneSidedTransaction(context.Context, *BroadcastSignedOneSidedTransactionRequest) (*BroadcastSignedOneSidedTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastSignedOneSidedTransaction not implemented")
}
func (UnimplementedWalletServer) Transfer(context.Context, *TransferRequest) (*TransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedWalletServer) GetTransactionInfo(context.Context, *GetTransactionInfoRequest) (*GetTransactionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionInfo not implemented")
}
func (UnimplementedWalletServer) GetCompletedTransactions(*GetCompletedTransactionsRequest, Wallet_GetCompletedTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCompletedTransactions not implemented")
}
func (UnimplementedWalletServer) GetBlockHeightTransactions(context.Context, *GetBlockHeightTransactionsRequest) (*GetBlockHeightTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockHeightTransactions not implemented")
}
func (UnimplementedWalletServer) GetTransactionPayRefs(context.Context, *GetTransactionPayRefsRequest) (*GetTransactionPayRefsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionPayRefs not implemented")
}
func (UnimplementedWalletServer) GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedWalletServer) GetUnspentAmounts(context.Context, *Empty) (*GetUnspentAmountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnspentAmounts not implemented")
}
func (UnimplementedWalletServer) CoinSplit(context.Context, *CoinSplitRequest) (*CoinSplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoinSplit not implemented")
}
func (UnimplementedWalletServer) ImportUtxos(context.Context, *ImportUtxosRequest) (*ImportUtxosResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportUtxos not implemented")
}
func (UnimplementedWalletServer) GetNetworkStatus(context.Context, *Empty) (*NetworkStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkStatus not implemented")
}
func (UnimplementedWalletServer) GetConnectedHttpPeer(context.Context, *Empty) (*GetConnectedHttpPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectedHttpPeer not implemented")
}
func (UnimplementedWalletServer) CancelTransaction(context.Context, *CancelTransactionRequest) (*CancelTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelTransaction not implemented")
}
func (UnimplementedWalletServer) RevalidateAllTransactions(context.Context, *RevalidateRequest) (*RevalidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevalidateAllTransactions not implemented")
}
func (UnimplementedWalletServer) ValidateAllTransactions(context.Context, *ValidateRequest) (*ValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAllTransactions not implemented")
}
func (UnimplementedWalletServer) SendShaAtomicSwapTransaction(context.Context, *SendShaAtomicSwapRequest) (*SendShaAtomicSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendShaAtomicSwapTransaction not implemented")
}
func (UnimplementedWalletServer) CreateBurnTransaction(context.Context, *CreateBurnTransactionRequest) (*CreateBurnTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBurnTransaction not implemented")
}
func (UnimplementedWalletServer) ClaimShaAtomicSwapTransaction(context.Context, *ClaimShaAtomicSwapRequest) (*ClaimShaAtomicSwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimShaAtomicSwapTransaction not implemented")
}
func (UnimplementedWalletServer) ClaimHtlcRefundTransaction(context.Context, *ClaimHtlcRefundRequest) (*ClaimHtlcRefundResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimHtlcRefundTransaction not implemented")
}
func (UnimplementedWalletServer) CreateTemplateRegistration(context.Context, *CreateTemplateRegistrationRequest) (*CreateTemplateRegistrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTemplateRegistration not implemented")
}
func (UnimplementedWalletServer) SignMessage(context.Context, *SignMessageRequest) (*SignMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignMessage not implemented")
}
func (UnimplementedWalletServer) StreamTransactionEvents(*TransactionEventRequest, Wallet_StreamTransactionEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamTransactionEvents not implemented")
}
func (UnimplementedWalletServer) ImportTransactions(context.Context, *ImportTransactionsRequest) (*ImportTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportTransactions not implemented")
}
func (UnimplementedWalletServer) GetAllCompletedTransactions(context.Context, *GetAllCompletedTransactionsRequest) (*GetAllCompletedTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCompletedTransactions not implemented")
}
func (UnimplementedWalletServer) GetAllCompletedTransactionsStream(*GetAllCompletedTransactionsRequest, Wallet_GetAllCompletedTransactionsStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllCompletedTransactionsStream not implemented")
}
func (UnimplementedWalletServer) GetPaymentByReference(context.Context, *GetPaymentByReferenceRequest) (*GetPaymentByReferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentByReference not implemented")
}
func (UnimplementedWalletServer) GetFeeEstimate(context.Context, *GetFeeEstimateRequest) (*GetFeeEstimateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeEstimate not implemented")
}
func (UnimplementedWalletServer) GetFeePerGramStats(context.Context, *GetFeePerGramStatsRequest) (*GetFeePerGramStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeePerGramStats not implemented")
}
func (UnimplementedWalletServer) ReplaceByFee(context.Context, *ReplaceByFeeRequest) (*ReplaceByFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplaceByFee not implemented")
}
func (UnimplementedWalletServer) UserPayForFee(context.Context, *UserPayForFeeRequest) (*UserPayForFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserPayForFee not implemented")
}
func (UnimplementedWalletServer) RegisterValidatorNode(context.Context, *RegisterValidatorNodeRequest) (*RegisterValidatorNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterValidatorNode not implemented")
}
func (UnimplementedWalletServer) SubmitValidatorEvictionProof(context.Context, *SubmitValidatorEvictionProofRequest) (*SubmitValidatorEvictionProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitValidatorEvictionProof not implemented")
}
func (UnimplementedWalletServer) SubmitValidatorNodeExit(context.Context, *SubmitValidatorNodeExitRequest) (*SubmitValidatorNodeExitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitValidatorNodeExit not implemented")
}
func (UnimplementedWalletServer) mustEmbedUnimplementedWalletServer() {}

// UnsafeWalletServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WalletServer will
// result in compilation errors.
type UnsafeWalletServer interface {
	mustEmbedUnimplementedWalletServer()
}

func RegisterWalletServer(s grpc.ServiceRegistrar, srv WalletServer) {
	s.RegisterService(&Wallet_ServiceDesc, srv)
}

func _Wallet_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetState(ctx, req.(*GetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CheckConnectivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CheckConnectivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_CheckConnectivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CheckConnectivity(ctx, req.(*GetConnectivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CheckForUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CheckForUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_CheckForUpdates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CheckForUpdates(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_Identify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).Identify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_Identify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).Identify(ctx, req.(*GetIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetAddress(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetPaymentIdAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentIdAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetPaymentIdAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetPaymentIdAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetPaymentIdAddress(ctx, req.(*GetPaymentIdAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetCompleteAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetCompleteAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetCompleteAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetCompleteAddress(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_PrepareOneSidedTransactionForSigning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareOneSidedTransactionForSigningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).PrepareOneSidedTransactionForSigning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_PrepareOneSidedTransactionForSigning_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).PrepareOneSidedTransactionForSigning(ctx, req.(*PrepareOneSidedTransactionForSigningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_BroadcastSignedOneSidedTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastSignedOneSidedTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).BroadcastSignedOneSidedTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_BroadcastSignedOneSidedTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).BroadcastSignedOneSidedTransaction(ctx, req.(*BroadcastSignedOneSidedTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_Transfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).Transfer(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetTransactionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetTransactionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetTransactionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetTransactionInfo(ctx, req.(*GetTransactionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetCompletedTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetCompletedTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServer).GetCompletedTransactions(m, &walletGetCompletedTransactionsServer{ServerStream: stream})
}

type Wallet_GetCompletedTransactionsServer interface {
	Send(*GetCompletedTransactionsResponse) error
	grpc.ServerStream
}

type walletGetCompletedTransactionsServer struct {
	grpc.ServerStream
}

func (x *walletGetCompletedTransactionsServer) Send(m *GetCompletedTransactionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Wallet_GetBlockHeightTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockHeightTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetBlockHeightTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetBlockHeightTransactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetBlockHeightTransactions(ctx, req.(*GetBlockHeightTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetTransactionPayRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionPayRefsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetTransactionPayRefs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetTransactionPayRefs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetTransactionPayRefs(ctx, req.(*GetTransactionPayRefsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetUnspentAmounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetUnspentAmounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetUnspentAmounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetUnspentAmounts(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CoinSplit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoinSplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CoinSplit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_CoinSplit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CoinSplit(ctx, req.(*CoinSplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ImportUtxos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportUtxosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ImportUtxos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_ImportUtxos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ImportUtxos(ctx, req.(*ImportUtxosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetNetworkStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetNetworkStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetNetworkStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetNetworkStatus(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetConnectedHttpPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetConnectedHttpPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetConnectedHttpPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetConnectedHttpPeer(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CancelTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CancelTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_CancelTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CancelTransaction(ctx, req.(*CancelTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_RevalidateAllTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevalidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).RevalidateAllTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_RevalidateAllTransactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).RevalidateAllTransactions(ctx, req.(*RevalidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ValidateAllTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ValidateAllTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_ValidateAllTransactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ValidateAllTransactions(ctx, req.(*ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_SendShaAtomicSwapTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendShaAtomicSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).SendShaAtomicSwapTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_SendShaAtomicSwapTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).SendShaAtomicSwapTransaction(ctx, req.(*SendShaAtomicSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CreateBurnTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBurnTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CreateBurnTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_CreateBurnTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CreateBurnTransaction(ctx, req.(*CreateBurnTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ClaimShaAtomicSwapTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimShaAtomicSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ClaimShaAtomicSwapTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_ClaimShaAtomicSwapTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ClaimShaAtomicSwapTransaction(ctx, req.(*ClaimShaAtomicSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ClaimHtlcRefundTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimHtlcRefundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ClaimHtlcRefundTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_ClaimHtlcRefundTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ClaimHtlcRefundTransaction(ctx, req.(*ClaimHtlcRefundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_CreateTemplateRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTemplateRegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).CreateTemplateRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_CreateTemplateRegistration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).CreateTemplateRegistration(ctx, req.(*CreateTemplateRegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_SignMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).SignMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_SignMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).SignMessage(ctx, req.(*SignMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_StreamTransactionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TransactionEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServer).StreamTransactionEvents(m, &walletStreamTransactionEventsServer{ServerStream: stream})
}

type Wallet_StreamTransactionEventsServer interface {
	Send(*TransactionEventResponse) error
	grpc.ServerStream
}

type walletStreamTransactionEventsServer struct {
	grpc.ServerStream
}

func (x *walletStreamTransactionEventsServer) Send(m *TransactionEventResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Wallet_ImportTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ImportTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_ImportTransactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ImportTransactions(ctx, req.(*ImportTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetAllCompletedTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllCompletedTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetAllCompletedTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetAllCompletedTransactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetAllCompletedTransactions(ctx, req.(*GetAllCompletedTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetAllCompletedTransactionsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetAllCompletedTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WalletServer).GetAllCompletedTransactionsStream(m, &walletGetAllCompletedTransactionsStreamServer{ServerStream: stream})
}

type Wallet_GetAllCompletedTransactionsStreamServer interface {
	Send(*GetCompletedTransactionsResponse) error
	grpc.ServerStream
}

type walletGetAllCompletedTransactionsStreamServer struct {
	grpc.ServerStream
}

func (x *walletGetAllCompletedTransactionsStreamServer) Send(m *GetCompletedTransactionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Wallet_GetPaymentByReference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentByReferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetPaymentByReference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetPaymentByReference_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetPaymentByReference(ctx, req.(*GetPaymentByReferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetFeeEstimate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeEstimateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetFeeEstimate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetFeeEstimate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetFeeEstimate(ctx, req.(*GetFeeEstimateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_GetFeePerGramStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeePerGramStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).GetFeePerGramStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_GetFeePerGramStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).GetFeePerGramStats(ctx, req.(*GetFeePerGramStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_ReplaceByFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplaceByFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).ReplaceByFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_ReplaceByFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).ReplaceByFee(ctx, req.(*ReplaceByFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_UserPayForFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPayForFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).UserPayForFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_UserPayForFee_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).UserPayForFee(ctx, req.(*UserPayForFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_RegisterValidatorNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterValidatorNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).RegisterValidatorNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_RegisterValidatorNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).RegisterValidatorNode(ctx, req.(*RegisterValidatorNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_SubmitValidatorEvictionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitValidatorEvictionProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).SubmitValidatorEvictionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_SubmitValidatorEvictionProof_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).SubmitValidatorEvictionProof(ctx, req.(*SubmitValidatorEvictionProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wallet_SubmitValidatorNodeExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitValidatorNodeExitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WalletServer).SubmitValidatorNodeExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Wallet_SubmitValidatorNodeExit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WalletServer).SubmitValidatorNodeExit(ctx, req.(*SubmitValidatorNodeExitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Wallet_ServiceDesc is the grpc.ServiceDesc for Wallet service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Wallet_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tari.rpc.Wallet",
	HandlerType: (*WalletServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersion",
			Handler:    _Wallet_GetVersion_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _Wallet_GetState_Handler,
		},
		{
			MethodName: "CheckConnectivity",
			Handler:    _Wallet_CheckConnectivity_Handler,
		},
		{
			MethodName: "CheckForUpdates",
			Handler:    _Wallet_CheckForUpdates_Handler,
		},
		{
			MethodName: "Identify",
			Handler:    _Wallet_Identify_Handler,
		},
		{
			MethodName: "GetAddress",
			Handler:    _Wallet_GetAddress_Handler,
		},
		{
			MethodName: "GetPaymentIdAddress",
			Handler:    _Wallet_GetPaymentIdAddress_Handler,
		},
		{
			MethodName: "GetCompleteAddress",
			Handler:    _Wallet_GetCompleteAddress_Handler,
		},
		{
			MethodName: "PrepareOneSidedTransactionForSigning",
			Handler:    _Wallet_PrepareOneSidedTransactionForSigning_Handler,
		},
		{
			MethodName: "BroadcastSignedOneSidedTransaction",
			Handler:    _Wallet_BroadcastSignedOneSidedTransaction_Handler,
		},
		{
			MethodName: "Transfer",
			Handler:    _Wallet_Transfer_Handler,
		},
		{
			MethodName: "GetTransactionInfo",
			Handler:    _Wallet_GetTransactionInfo_Handler,
		},
		{
			MethodName: "GetBlockHeightTransactions",
			Handler:    _Wallet_GetBlockHeightTransactions_Handler,
		},
		{
			MethodName: "GetTransactionPayRefs",
			Handler:    _Wallet_GetTransactionPayRefs_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _Wallet_GetBalance_Handler,
		},
		{
			MethodName: "GetUnspentAmounts",
			Handler:    _Wallet_GetUnspentAmounts_Handler,
		},
		{
			MethodName: "CoinSplit",
			Handler:    _Wallet_CoinSplit_Handler,
		},
		{
			MethodName: "ImportUtxos",
			Handler:    _Wallet_ImportUtxos_Handler,
		},
		{
			MethodName: "GetNetworkStatus",
			Handler:    _Wallet_GetNetworkStatus_Handler,
		},
		{
			MethodName: "GetConnectedHttpPeer",
			Handler:    _Wallet_GetConnectedHttpPeer_Handler,
		},
		{
			MethodName: "CancelTransaction",
			Handler:    _Wallet_CancelTransaction_Handler,
		},
		{
			MethodName: "RevalidateAllTransactions",
			Handler:    _Wallet_RevalidateAllTransactions_Handler,
		},
		{
			MethodName: "ValidateAllTransactions",
			Handler:    _Wallet_ValidateAllTransactions_Handler,
		},
		{
			MethodName: "SendShaAtomicSwapTransaction",
			Handler:    _Wallet_SendShaAtomicSwapTransaction_Handler,
		},
		{
			MethodName: "CreateBurnTransaction",
			Handler:    _Wallet_CreateBurnTransaction_Handler,
		},
		{
			MethodName: "ClaimShaAtomicSwapTransaction",
			Handler:    _Wallet_ClaimShaAtomicSwapTransaction_Handler,
		},
		{
			MethodName: "ClaimHtlcRefundTransaction",
			Handler:    _Wallet_ClaimHtlcRefundTransaction_Handler,
		},
		{
			MethodName: "CreateTemplateRegistration",
			Handler:    _Wallet_CreateTemplateRegistration_Handler,
		},
		{
			MethodName: "SignMessage",
			Handler:    _Wallet_SignMessage_Handler,
		},
		{
			MethodName: "ImportTransactions",
			Handler:    _Wallet_ImportTransactions_Handler,
		},
		{
			MethodName: "GetAllCompletedTransactions",
			Handler:    _Wallet_GetAllCompletedTransactions_Handler,
		},
		{
			MethodName: "GetPaymentByReference",
			Handler:    _Wallet_GetPaymentByReference_Handler,
		},
		{
			MethodName: "GetFeeEstimate",
			Handler:    _Wallet_GetFeeEstimate_Handler,
		},
		{
			MethodName: "GetFeePerGramStats",
			Handler:    _Wallet_GetFeePerGramStats_Handler,
		},
		{
			MethodName: "ReplaceByFee",
			Handler:    _Wallet_ReplaceByFee_Handler,
		},
		{
			MethodName: "UserPayForFee",
			Handler:    _Wallet_UserPayForFee_Handler,
		},
		{
			MethodName: "RegisterValidatorNode",
			Handler:    _Wallet_RegisterValidatorNode_Handler,
		},
		{
			MethodName: "SubmitValidatorEvictionProof",
			Handler:    _Wallet_SubmitValidatorEvictionProof_Handler,
		},
		{
			MethodName: "SubmitValidatorNodeExit",
			Handler:    _Wallet_SubmitValidatorNodeExit_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetCompletedTransactions",
			Handler:       _Wallet_GetCompletedTransactions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamTransactionEvents",
			Handler:       _Wallet_StreamTransactionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAllCompletedTransactionsStream",
			Handler:       _Wallet_GetAllCompletedTransactionsStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "wallet.proto",
}
